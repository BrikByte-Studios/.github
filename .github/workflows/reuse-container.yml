name: Reuse • Deploy From Built Image

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
        description: "Target env: staging | prod"
      image-name:
        type: string
        required: true
        description: "Full image ref incl. registry, e.g. ghcr.io/brikbytes/brikbyteos-sample-service"
      tag:
        type: string
        required: true
        description: "Tag to deploy (typically commit SHA from build job)"
      dry-run:
        type: boolean
        required: false
        default: false
        description: "If true, don't push image / don't apply Helm"
    secrets:
      REGISTRY_USERNAME:
        required: false
      REGISTRY_PASSWORD:
        required: false
      KUBE_CONFIG:
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    # Bind this job to the target Environment in the caller repo.
    # For prod, that Environment should require manual approval.
    environment: ${{ inputs.environment }}

    permissions:
      contents: read
      packages: write   # needed to push to ghcr.io
      deployments: write

    steps:
      # -------------------------------------------------
      # 1. Checkout code of the calling repo
      #    We need infra/helm/ to run the Helm upgrade.
      # -------------------------------------------------
      - name: Checkout service repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # -------------------------------------------------
      # 2. Download artifacts from ci-build:
      #    - service-container-image (image.tar from build job)
      #    - build-metrics (build-metrics.json from build job)
      #    We will embed build-metrics.json in the audit record.
      # -------------------------------------------------
      - name: Download built image artifact
        uses: actions/download-artifact@v4
        with:
          name: service-container-image
          path: ./ci_image

      - name: Download build metrics
        uses: actions/download-artifact@v4
        with:
          name: build-metrics
          path: ./ci_metrics

      # -------------------------------------------------
      # 3. Load the exact prebuilt image tar
      #    We DO NOT rebuild. Deterministic promotion.
      #    We ensure it has the correct final tag.
      # -------------------------------------------------
      - name: Load container image tar
        shell: bash
        env:
          IMAGE: ${{ inputs.image-name }}
          TAG: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          docker load -i ./ci_image/image.tar

          # Re-tag explicitly in case the tar didn't embed exactly $IMAGE:$TAG
          docker tag "$IMAGE:$TAG" "$IMAGE:$TAG" || true

          echo "Loaded and tagged $IMAGE:$TAG from build artifact."

      # -------------------------------------------------
      # 3. Log in to registry
      #    - For ghcr.io we can usually use GITHUB_TOKEN, but
      #      we allow explicit username/password secrets for consistency.
      # -------------------------------------------------
      - name: Registry login
        if: ${{ inputs.dry-run == false }}
        shell: bash
        env:
          USERNAME: ${{ secrets.REGISTRY_USERNAME || github.actor }}
          PASSWORD: ${{ secrets.REGISTRY_PASSWORD || secrets.GITHUB_TOKEN }}
          IMAGE: ${{ inputs.image-name }}
        run: |
          set -euo pipefail
          REGISTRY_HOST=$(echo "$IMAGE" | cut -d/ -f1)
          echo "$PASSWORD" | docker login "$REGISTRY_HOST" -u "$USERNAME" --password-stdin
          echo "Logged in to $REGISTRY_HOST"

      # -------------------------------------------------
      # 5. Push the prebuilt image to the registry
      #    No rebuild here — this is the same image tested in CI.
      # -------------------------------------------------
      - name: Push image
        if: ${{ inputs.dry-run == false }}
        shell: bash
        env:
          IMAGE: ${{ inputs.image-name }}
          TAG: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          docker push "$IMAGE:$TAG"
          echo "Pushed $IMAGE:$TAG"

      # -------------------------------------------------
      # 6. Prepare kubeconfig for Helm rollout
      #    We expect KUBE_CONFIG as an env-scoped secret on the target environment.
      # -------------------------------------------------
      - name: Configure kube access
        if: ${{ inputs.dry-run == false }}
        shell: bash
        env:
          KCFG: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -euo pipefail

          if [ -z "${KCFG:-}" ]; then
            echo "::error::KUBE_CONFIG is empty or missing for environment '${{ inputs.environment }}'."
            echo "Add a secret named 'KUBE_CONFIG' to the '${{ inputs.environment }}' Environment in this repo (Settings → Environments)."
            exit 1
          fi

          mkdir -p $HOME/.kube
          echo "$KCFG" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "Wrote kubeconfig."

      # -------------------------------------------------
      # 7. Helm upgrade the environment
      #    Assumptions:
      #      - Helm chart: ./infra/helm
      #      - Env values: ./infra/helm/values/<env>.yaml
      #      - Release name == "<env>-release"
      #      - Namespace == "<env>"
      #    We override the image repo/tag so this exact build goes live.
      # -------------------------------------------------
      - name: Helm upgrade/apply
        if: ${{ inputs.dry-run == false }}
        shell: bash
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          IMAGE: ${{ inputs.image-name }}
          TAG: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          # we tie release name + namespace to environment for clarity
          RELEASE_NAME="${ENVIRONMENT}-release"
          NAMESPACE="${ENVIRONMENT}"
          VALUES_FILE="./infra/helm/values/${ENVIRONMENT}.yaml"

          if [ ! -f "$VALUES_FILE" ]; then
            echo "WARNING: values file $VALUES_FILE does not exist."
          fi

          helm upgrade --install "$RELEASE_NAME" ./infra/helm \
            --namespace "$NAMESPACE" \
            --create-namespace \
            ${VALUES_FILE:+-f "$VALUES_FILE"} \
            --set image.repository="$IMAGE" \
            --set image.tag="$TAG"

          echo "Helm upgrade complete for $ENVIRONMENT."

      # -------------------------------------------------
      # 8. Generate deployment audit record
      #    We embed:
      #      - service, tag, environment
      #      - timestamp, commit, actor, run URL
      #      - build_metrics.json contents (duration, cache info)
      #
      #    This goes to .audit/<env>/<YYYY-MM-DD>/deploy.json
      #    and will be uploaded as an artifact.
      # -------------------------------------------------
      - name: Generate deployment audit record
        id: audit
        shell: bash
        env:
          IMAGE: ${{ inputs.image-name }}
          TAG: ${{ inputs.tag }}
          ENVIRONMENT: ${{ inputs.environment }}
          DRYRUN: ${{ inputs.dry-run }}
        run: |
          set -euo pipefail

          TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          DATE_DIR=$(date -u +"%Y-%m-%d")

          mkdir -p .audit/"${ENVIRONMENT}"/"${DATE_DIR}"

          # read build metrics JSON from the artifact we downloaded above
          BUILD_METRICS_PATH="./ci_metrics/build-metrics.json"
          if [ -f "$BUILD_METRICS_PATH" ]; then
            BUILD_JSON=$(cat "$BUILD_METRICS_PATH")
          else
            BUILD_JSON="{}"
          fi

          cat > .audit/"${ENVIRONMENT}"/"${DATE_DIR}"/deploy.json <<EOF
          {
            "service": "${IMAGE}",
            "tag": "${TAG}",
            "environment": "${ENVIRONMENT}",
            "dry_run": ${DRYRUN},
            "timestamp_utc": "${TS}",
            "commit_sha": "${GITHUB_SHA}",
            "actor": "${GITHUB_ACTOR}",
            "workflow_run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "build_metrics": ${BUILD_JSON}
          }
          EOF

          echo "Generated .audit/${ENVIRONMENT}/${DATE_DIR}/deploy.json:"
          cat .audit/"${ENVIRONMENT}"/"${DATE_DIR}"/deploy.json

      # -------------------------------------------------
      # 9. Upload audit JSON so platform / compliance
      #    can grab it without cloning the repo.
      #    The artifact name is env-scoped for clarity.
      # -------------------------------------------------
      - name: Upload deployment audit artifact
        uses: actions/upload-artifact@v4
        with:
          name: deploy-audit-${{ inputs.environment }}
          path: .audit/${{ inputs.environment }}/**
          if-no-files-found: error
