name: Reuse • Semantic Version & Tag

on:
  workflow_call:
    inputs:
      allow-major:
        type: boolean
        default: false
        description: "Permit major bump (breaking changes). Default false."
      release-branch:
        type: string
        default: "main"
        description: "Branch we consider authoritative for releases."
      version-file:
        type: string
        default: "VERSION"
        description: "File in the caller repo that stores the current version (X.Y.Z)."
    secrets:
      GIT_PUSH_TOKEN:
        required: false
        description: "Optional PAT with perms to push tags/commits. Falls back to GITHUB_TOKEN."

jobs:
  semver:
    name: calc-next-version-and-tag
    runs-on: ubuntu-latest

    # Prevent racing two merges at once (scoped per repo)
    concurrency:
      group: ${{ github.repository }}-release-main
      cancel-in-progress: false

    permissions:
      contents: write         # push release/* branch with VERSION/CHANGELOG
      pull-requests: write    # open/edit PRs
      issues: write           # create/apply 'release' label

    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      changelog_fragment: ${{ steps.bump.outputs.changelog_fragment }}

    steps:
      # -----------------------------------------
      # 1) Checkout full history (need tags + logs)
      # -----------------------------------------
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.release-branch }}
          token: ${{ secrets.GIT_PUSH_TOKEN || github.token }}

      - name: Configure git identity
        run: |
          git config user.name "brikbyte-bot"
          git config user.email "platform+bot@brikbyte.local"

      # -----------------------------------------
      # 2) Detect last version tag (fallback v0.1.0)
      # -----------------------------------------
      - name: Detect last tag
        id: lasttag
        shell: bash
        run: |
          set -euo pipefail
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            LAST_TAG=$(git describe --tags --abbrev=0)
          else
            LAST_TAG="v0.1.0"
          fi
          echo "last_tag=$LAST_TAG" >> "$GITHUB_OUTPUT"
          echo "Last tag: $LAST_TAG"

      # -----------------------------------------
      # 3) Read current VERSION (fallback 0.1.0)
      # -----------------------------------------
      - name: Read current VERSION
        id: curver
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ inputs.version-file }}" ]; then
            CUR_VER=$(tr -d '[:space:]' < "${{ inputs.version-file }}")
          else
            CUR_VER="0.1.0"
          fi
          echo "cur_ver=$CUR_VER" >> "$GITHUB_OUTPUT"
          echo "Current version file says: $CUR_VER"

      # -----------------------------------------
      # 4) Classify commits since last tag
      # -----------------------------------------
      - name: Analyze commit messages
        id: classify
        shell: bash
        run: |
          set -euo pipefail
          LAST_TAG="${{ steps.lasttag.outputs.last_tag }}"
          COMMITS=$(git log --pretty=format:'%H%x09%s%x09%b' ${LAST_TAG}..HEAD || true)

          echo "Commits since $LAST_TAG:"
          echo "$COMMITS"

          HAS_BREAKING="false"; HAS_FEAT="false"; HAS_PATCH="false"
          ADDED=""; FIXED=""; BREAKING_NOTES=""

          while IFS=$'\t' read -r SHA SUBJECT BODY; do
            [ -z "$SHA" ] && continue
            SUBJECT_LC=$(echo "$SUBJECT" | tr '[:upper:]' '[:lower:]')
            BODY_LC=$(echo "$BODY" | tr '[:upper:]' '[:lower:]')

            # breaking: type! or BREAKING CHANGE footer
            if echo "$SUBJECT_LC" | grep -qE '!:|!$'; then HAS_BREAKING="true"; fi
            if echo "$BODY_LC"    | grep -q 'breaking change'; then HAS_BREAKING="true"; fi

            # minor: feat
            if echo "$SUBJECT_LC" | grep -qE '^feat(\(|:)\s?'; then
              HAS_FEAT="true"; ADDED="${ADDED}- ${SUBJECT}\n"
            fi

            # patch: fix/perf/refactor/chore/bugfix
            if echo "$SUBJECT_LC" | grep -qE '^(fix|perf|refactor|chore|bugfix)(\(|:)\s?'; then
              HAS_PATCH="true"; FIXED="${FIXED}- ${SUBJECT}\n"
            fi

            if echo "$SUBJECT_LC$BODY_LC" | grep -q 'breaking change'; then
              BREAKING_NOTES="${BREAKING_NOTES}- ${SUBJECT}\n"
            fi
          done <<< "$COMMITS"

          echo "has_breaking=$HAS_BREAKING" >> "$GITHUB_OUTPUT"
          echo "has_feat=$HAS_FEAT" >> "$GITHUB_OUTPUT"
          echo "has_patch=$HAS_PATCH" >> "$GITHUB_OUTPUT"

          printf "%b" "$ADDED"          > .changelog_added.txt
          printf "%b" "$FIXED"          > .changelog_fixed.txt
          printf "%b" "$BREAKING_NOTES" > .changelog_breaking.txt

      # -----------------------------------------
      # 5) Ensure 'release' label exists (idempotent)
      # -----------------------------------------
      - name: Ensure 'release' label exists
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if ! gh label list --limit 200 --json name -q '.[] | select(.name=="release")' | grep -q release; then
            gh label create "release" --color "0366d6" --description "Automated release PRs" || true
          fi

      - name: Verify gh CLI
        run: gh --version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # -----------------------------------------
      # 6) Bump version, update changelog, open PR
      #    (No tag push here; tag after PR merge)
      # -----------------------------------------
      - name: Bump version, update changelog, open release PR
        id: bump
        shell: bash
        env:
          ALLOW_MAJOR: ${{ inputs.allow-major }}
          VERSION_FILE: ${{ inputs.version-file }}
          REL_BRANCH: ${{ inputs.release-branch }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          CUR_VER="${{ steps.curver.outputs.cur_ver }}"
          HAS_BREAKING="${{ steps.classify.outputs.has_breaking }}"
          HAS_FEAT="${{ steps.classify.outputs.has_feat }}"
          HAS_PATCH="${{ steps.classify.outputs.has_patch }}"

          MAJOR=$(echo "$CUR_VER" | cut -d. -f1)
          MINOR=$(echo "$CUR_VER" | cut -d. -f2)
          PATCH=$(echo "$CUR_VER" | cut -d. -f3)

          if [ "$HAS_BREAKING" = "true" ]; then
            if [ "$ALLOW_MAJOR" = "true" ]; then
              MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0; BUMP_TYPE="major"
            else
              echo "::error::Breaking changes detected but allow-major=false. Stop."
              echo "version=BLOCKED_MAJOR" >> "$GITHUB_OUTPUT"
              echo "tag=BLOCKED_MAJOR" >> "$GITHUB_OUTPUT"
              echo "changelog_fragment=" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          elif [ "$HAS_FEAT" = "true" ]; then
            MINOR=$((MINOR+1)); PATCH=0; BUMP_TYPE="minor"
          elif [ "$HAS_PATCH" = "true" ]; then
            PATCH=$((PATCH+1)); BUMP_TYPE="patch"
          else
            PATCH=$((PATCH+1)); BUMP_TYPE="patch"
          fi

          NEXT_VER="${MAJOR}.${MINOR}.${PATCH}"
          NEXT_TAG="v${NEXT_VER}"
          DATE_UTC=$(date -u +"%Y-%m-%d")

          echo "Decided bump: $BUMP_TYPE => ${NEXT_TAG}"

          ADDED=$(cat .changelog_added.txt || true)
          FIXED=$(cat .changelog_fixed.txt || true)
          BREAKING_NOTES=$(cat .changelog_breaking.txt || true)

          CHANGELOG_FRAGMENT="## ${NEXT_TAG} - ${DATE_UTC}\n"
          if [ -n "$ADDED" ]; then
            CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Added\n${ADDED}\n"
          fi
          if [ -n "$FIXED" ]; then
            CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Fixed\n${FIXED}\n"
          fi
          if [ -n "$BREAKING_NOTES" ]; then
            CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Breaking\n${BREAKING_NOTES}\n"
          fi

          # 1) update VERSION
          echo "${NEXT_VER}" > "$VERSION_FILE"

          # 2) prepend changelog block
          if [ -f CHANGELOG.md ]; then
            (printf "%b\n\n" "$CHANGELOG_FRAGMENT"; cat CHANGELOG.md) > CHANGELOG.new
            mv CHANGELOG.new CHANGELOG.md
          else
            printf "%b\n" "$CHANGELOG_FRAGMENT" > CHANGELOG.md
          fi

          git add "$VERSION_FILE" CHANGELOG.md
          git commit -m "chore(release): ${NEXT_TAG}"

          # 3) create/update release branch
          REL_BRANCH_CANDIDATE="release/${NEXT_TAG}"
          git branch -f "$REL_BRANCH_CANDIDATE" HEAD
          git push -fu origin "$REL_BRANCH_CANDIDATE"

          # 4) create or update PR (then add label, best-effort)
          printf "%b" "$CHANGELOG_FRAGMENT" > .release-notes-fragment.md

          if gh pr view "$REL_BRANCH_CANDIDATE" >/dev/null 2>&1; then
            echo "PR already exists for $REL_BRANCH_CANDIDATE → updating"
            gh pr edit "$REL_BRANCH_CANDIDATE" \
              --title "chore(release): ${NEXT_TAG}" \
              --body-file .release-notes-fragment.md
          else
            echo "Creating PR $REL_BRANCH_CANDIDATE → $REL_BRANCH"
            gh pr create \
              --head "$REL_BRANCH_CANDIDATE" \
              --base "$REL_BRANCH" \
              --title "chore(release): ${NEXT_TAG}" \
              --body-file .release-notes-fragment.md
          fi

          # add label (non-fatal)
          gh pr edit "$REL_BRANCH_CANDIDATE" --add-label "release" || echo "Warn: could not add 'release' label"

          # outputs
          printf "%s" "$CHANGELOG_FRAGMENT" | sed ':a;N;$!ba;s/\n/\\n/g' > .frag.out
          echo "version=${NEXT_VER}"           >> "$GITHUB_OUTPUT"
          echo "tag=${NEXT_TAG}"               >> "$GITHUB_OUTPUT"
          echo "changelog_fragment=$(cat .frag.out)" >> "$GITHUB_OUTPUT"
