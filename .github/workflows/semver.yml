name: Reuse â€¢ Semantic Version & Tag

on:
  workflow_call:
    inputs:
      allow-major:
        type: boolean
        default: false
      release-branch:
        type: string
        default: "main"
      version-file:
        type: string
        default: "VERSION"
    secrets:
      BOT_TOKEN:
        required: true
        description: "Fine-grained PAT with Contents RW + PRs RW"

jobs:
  semver:
    name: calc-next-version-and-tag
    runs-on: ubuntu-latest

    concurrency:
      group: ${{ github.repository }}-release-main
      cancel-in-progress: false

    # These affect the ephemeral GITHUB_TOKEN; PAT still used explicitly below.
    permissions:
      contents: write
      pull-requests: write
      issues: write

    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      changelog_fragment: ${{ steps.bump.outputs.changelog_fragment }}

    steps:
      - name: Checkout full history (use PAT)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.release-branch }}
          token: ${{ secrets.BOT_TOKEN }}

      - name: Configure git & gh with PAT
        env:
          BOT: ${{ secrets.BOT_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          git config user.name  "brikbyte-bot"
          git config user.email "platform+bot@brikbyte.local"
          # Ensure pushes (branches/tags) use PAT
          git remote set-url origin "https://x-access-token:${BOT}@github.com/${REPO}.git"
          # Auth for gh CLI
          echo "${BOT}" | gh auth login --with-token

      - name: Detect last tag
        id: lasttag
        shell: bash
        run: |
          set -euo pipefail
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            LAST_TAG=$(git describe --tags --abbrev=0)
          else
            LAST_TAG="v0.1.0"
          fi
          echo "last_tag=$LAST_TAG" >> "$GITHUB_OUTPUT"

      - name: Read current VERSION
        id: curver
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ inputs.version-file }}" ]; then
            CUR_VER=$(tr -d '[:space:]' < "${{ inputs.version-file }}")
          else
            CUR_VER="0.1.0"
          fi
          echo "cur_ver=$CUR_VER" >> "$GITHUB_OUTPUT"

      - name: Analyze commit messages
        id: classify
        shell: bash
        run: |
          set -euo pipefail
          LAST_TAG="${{ steps.lasttag.outputs.last_tag }}"
          COMMITS=$(git log --pretty=format:'%H%x09%s%x09%b' ${LAST_TAG}..HEAD || true)

          HAS_BREAKING="false"; HAS_FEAT="false"; HAS_PATCH="false"
          ADDED=""; FIXED=""; BREAKING_NOTES=""

          while IFS=$'\t' read -r SHA SUBJECT BODY; do
            [ -z "$SHA" ] && continue
            SUBJECT_LC=$(echo "$SUBJECT" | tr '[:upper:]' '[:lower:]')
            BODY_LC=$(echo "$BODY" | tr '[:upper:]' '[:lower:]')

            if echo "$SUBJECT_LC" | grep -qE '!:|!$'; then HAS_BREAKING="true"; fi
            if echo "$BODY_LC"    | grep -q 'breaking change'; then HAS_BREAKING="true"; fi
            if echo "$SUBJECT_LC" | grep -qE '^feat(\(|:)\s?'; then
              HAS_FEAT="true"; ADDED="${ADDED}- ${SUBJECT}\n"
            fi
            if echo "$SUBJECT_LC" | grep -qE '^(fix|perf|refactor|chore|bugfix)(\(|:)\s?'; then
              HAS_PATCH="true"; FIXED="${FIXED}- ${SUBJECT}\n"
            fi
            if echo "$SUBJECT_LC$BODY_LC" | grep -q 'breaking change'; then
              BREAKING_NOTES="${BREAKING_NOTES}- ${SUBJECT}\n"
            fi
          done <<< "$COMMITS"

          echo "has_breaking=$HAS_BREAKING" >> "$GITHUB_OUTPUT"
          echo "has_feat=$HAS_FEAT" >> "$GITHUB_OUTPUT"
          echo "has_patch=$HAS_PATCH" >> "$GITHUB_OUTPUT"

          printf "%b" "$ADDED"          > .changelog_added.txt
          printf "%b" "$FIXED"          > .changelog_fixed.txt
          printf "%b" "$BREAKING_NOTES" > .changelog_breaking.txt

      - name: Ensure 'release' label exists (via PAT)
        env:
          GH_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          set -euo pipefail
          if ! gh label list --limit 200 --json name -q '.[] | select(.name=="release")' | grep -q release; then
            gh label create "release" --color "0366d6" --description "Automated release PRs" || true
          fi

      - name: Bump version, update changelog, open release PR (via PAT)
        id: bump
        shell: bash
        env:
          ALLOW_MAJOR: ${{ inputs.allow-major }}
          VERSION_FILE: ${{ inputs.version-file }}
          REL_BRANCH: ${{ inputs.release-branch }}
          GH_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          set -euo pipefail
          CUR_VER="${{ steps.curver.outputs.cur_ver }}"
          HAS_BREAKING="${{ steps.classify.outputs.has_breaking }}"
          HAS_FEAT="${{ steps.classify.outputs.has_feat }}"
          HAS_PATCH="${{ steps.classify.outputs.has_patch }}"

          MAJOR=$(echo "$CUR_VER" | cut -d. -f1)
          MINOR=$(echo "$CUR_VER" | cut -d. -f2)
          PATCH=$(echo "$CUR_VER" | cut -d. -f3)

          if [ "$HAS_BREAKING" = "true" ]; then
            if [ "$ALLOW_MAJOR" = "true" ]; then
              MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0; BUMP_TYPE="major"
            else
              echo "::error::Breaking changes detected but allow-major=false. Stop."
              echo "version=BLOCKED_MAJOR" >> "$GITHUB_OUTPUT"
              echo "tag=BLOCKED_MAJOR" >> "$GITHUB_OUTPUT"
              echo "changelog_fragment=" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          elif [ "$HAS_FEAT" = "true" ]; then
            MINOR=$((MINOR+1)); PATCH=0; BUMP_TYPE="minor"
          elif [ "$HAS_PATCH" = "true" ]; then
            PATCH=$((PATCH+1)); BUMP_TYPE="patch"
          else
            PATCH=$((PATCH+1)); BUMP_TYPE="patch"
          fi

          NEXT_VER="${MAJOR}.${MINOR}.${PATCH}"
          NEXT_TAG="v${NEXT_VER}"
          DATE_UTC=$(date -u +"%Y-%m-%d")

          ADDED=$(cat .changelog_added.txt || true)
          FIXED=$(cat .changelog_fixed.txt || true)
          BREAKING_NOTES=$(cat .changelog_breaking.txt || true)

          CHANGELOG_FRAGMENT="## ${NEXT_TAG} - ${DATE_UTC}\n"
          [ -n "$ADDED" ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Added\n${ADDED}\n"
          [ -n "$FIXED" ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Fixed\n${FIXED}\n"
          [ -n "$BREAKING_NOTES" ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Breaking\n${BREAKING_NOTES}\n"

          echo "${NEXT_VER}" > "$VERSION_FILE"

          if [ -f CHANGELOG.md ]; then
            (printf "%b\n\n" "$CHANGELOG_FRAGMENT"; cat CHANGELOG.md) > CHANGELOG.new
            mv CHANGELOG.new CHANGELOG.md
          else
            printf "%b\n" "$CHANGELOG_FRAGMENT" > CHANGELOG.md
          fi

          git add "$VERSION_FILE" CHANGELOG.md
          git commit -m "chore(release): ${NEXT_TAG}"

          REL_BRANCH_CANDIDATE="release/${NEXT_TAG}"
          git branch -f "$REL_BRANCH_CANDIDATE" HEAD
          git push -fu origin "$REL_BRANCH_CANDIDATE"

          printf "%b" "$CHANGELOG_FRAGMENT" > .release-notes-fragment.md

          if gh pr view "$REL_BRANCH_CANDIDATE" >/dev/null 2>&1; then
            gh pr edit "$REL_BRANCH_CANDIDATE" \
              --title "chore(release): ${NEXT_TAG}" \
              --body-file .release-notes-fragment.md
          else
            gh pr create \
              --head "$REL_BRANCH_CANDIDATE" \
              --base "$REL_BRANCH" \
              --title "chore(release): ${NEXT_TAG}" \
              --body-file .release-notes-fragment.md
          fi

          gh pr edit "$REL_BRANCH_CANDIDATE" --add-label "release" || true

          printf "%s" "$CHANGELOG_FRAGMENT" | sed ':a;N;$!ba;s/\n/\\n/g' > .frag.out
          echo "version=${NEXT_VER}"           >> "$GITHUB_OUTPUT"
          echo "tag=${NEXT_TAG}"               >> "$GITHUB_OUTPUT"
          echo "changelog_fragment=$(cat .frag.out)" >> "$GITHUB_OUTPUT"
