name: Reuse • Semantic Version & Tag

on:
  workflow_call:
    inputs:
      allow-major:
        type: boolean
        default: false
        description: "Permit major bump (breaking changes). Default false."
      release-branch:
        type: string
        default: "main"
        description: "Branch we consider authoritative for releases."
      version-file:
        type: string
        default: "VERSION"
        description: "File in the caller repo that stores the current version (X.Y.Z)."
    secrets:
      GIT_PUSH_TOKEN:
        required: false
        description: "Optional PAT with perms to push tags/commits. Falls back to GITHUB_TOKEN."
        
    outputs:
      version:
        description: "Computed X.Y.Z"
        value: ${{ jobs.semver.outputs.version }}
      tag:
        description: "Computed vX.Y.Z"
        value: ${{ jobs.semver.outputs.tag }}
      changelog_fragment:
        description: "Escaped markdown changelog fragment"
        value: ${{ jobs.semver.outputs.changelog_fragment }}

jobs:
  semver:
    name: calc-next-version-and-tag
    runs-on: ubuntu-latest

    # Prevent racing two merges at once (scoped per repo)
    concurrency:
      group: ${{ github.repository }}-release-main
      cancel-in-progress: false

    permissions:
      contents: write         # push release/* branch with VERSION/CHANGELOG
      pull-requests: write    # open/edit PRs
      issues: write           # create/apply 'release' label

    # Outputs come from steps.emit.*
    outputs:
      version:             ${{ steps.emit.outputs.version }}
      tag:                 ${{ steps.emit.outputs.tag }}
      changelog_fragment:  ${{ steps.emit.outputs.changelog_fragment }}

    steps:
      # -----------------------------------------
      # 1) Checkout full history (need tags + logs)
      # -----------------------------------------
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.release-branch }}
          token: ${{ secrets.GIT_PUSH_TOKEN || github.token }}

      - name: Configure git identity
        run: |
          git config user.name "brikbyte-bot"
          git config user.email "platform+bot@brikbyte.local"

      # -----------------------------------------
      # 2) Detect last version tag (fallback v0.1.0)
      # -----------------------------------------
      - name: Detect last tag
        id: lasttag
        shell: bash
        run: |
          set -euo pipefail
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            echo "last_tag=$(git describe --tags --abbrev=0)" >> "$GITHUB_OUTPUT"
          else
            echo "last_tag=" >> "$GITHUB_OUTPUT"   # ← empty = no tag yet
          fi

      # -----------------------------------------
      # 3) Read current VERSION (fallback 0.1.0)
      # -----------------------------------------
      - name: Read current VERSION
        id: curver
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ inputs.version-file }}" ]; then
            CUR_VER=$(tr -d '[:space:]' < "${{ inputs.version-file }}")
          else
            CUR_VER="0.1.0"
          fi
          echo "cur_ver=$CUR_VER" >> "$GITHUB_OUTPUT"
          echo "Current version file says: $CUR_VER"

      # -----------------------------------------
      # 4) Classify commits since last tag
      # -----------------------------------------
      - name: Analyze commit messages
        id: classify
        shell: bash
        run: |
          set -euo pipefail
          LAST="${{ steps.lasttag.outputs.last_tag }}"
          if [ -n "$LAST" ]; then
            COMMITS=$(git log --pretty=format:'%H%x09%s%x09%b' "$LAST"..HEAD || true)
          else
            # no prior tag → include all commits from repo root
            ROOT=$(git rev-list --max-parents=0 HEAD | tail -n1)
            COMMITS=$(git log --pretty=format:'%H%x09%s%x09%b' "$ROOT"..HEAD || true)
          fi

          HAS_BREAKING=false; HAS_FEAT=false; HAS_PATCH=false
          ADDED=""; FIXED=""; BREAKING_NOTES=""

          while IFS=$'\t' read -r SHA SUBJECT BODY; do
            [ -z "$SHA" ] && continue
            s=$(echo "$SUBJECT" | tr '[:upper:]' '[:lower:]')
            b=$(echo "$BODY"    | tr '[:upper:]' '[:lower:]')

            [[ "$s" =~ (!:|!$) ]] && HAS_BREAKING=true
            echo "$b" | grep -qi 'breaking change' && HAS_BREAKING=true

            echo "$s" | grep -qE '^feat(\(|:)' && { HAS_FEAT=true;  ADDED="${ADDED}- ${SUBJECT}\n"; }
            echo "$s" | grep -qE '^(fix|perf|refactor|chore|bugfix)(\(|:)' && { HAS_PATCH=true; FIXED="${FIXED}- ${SUBJECT}\n"; }
            echo "$s$b" | grep -qi 'breaking change' && BREAKING_NOTES="${BREAKING_NOTES}- ${SUBJECT}\n"
          done <<< "$COMMITS"

          echo "has_breaking=$HAS_BREAKING" >> "$GITHUB_OUTPUT"
          echo "has_feat=$HAS_FEAT"         >> "$GITHUB_OUTPUT"
          echo "has_patch=$HAS_PATCH"       >> "$GITHUB_OUTPUT"

          printf "%b" "$ADDED"          > .changelog_added.txt
          printf "%b" "$FIXED"          > .changelog_fixed.txt
          printf "%b" "$BREAKING_NOTES" > .changelog_breaking.txt

      - name: Decide bump + update files (no tagging yet)
        id: bump
        shell: bash
        env:
          ALLOW_MAJOR:  ${{ inputs.allow-major }}
          VERSION_FILE: ${{ inputs.version-file }}
          REL_BRANCH:   ${{ inputs.release-branch }}
        run: |
          set -euo pipefail
          CUR_VER="${{ steps.curver.outputs.cur_ver }}"
          HAS_BREAKING="${{ steps.classify.outputs.has_breaking }}"
          HAS_FEAT="${{ steps.classify.outputs.has_feat }}"
          HAS_PATCH="${{ steps.classify.outputs.has_patch }}"

          MAJOR=${CUR_VER%%.*}
          MINOR=${CUR_VER#*.}; MINOR=${MINOR%%.*}
          PATCH=${CUR_VER##*.}

          if [ "$HAS_BREAKING" = "true" ]; then
            if [ "$ALLOW_MAJOR" = "true" ]; then
              MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0; BUMP_TYPE=major
            else
              echo "::error::Breaking changes detected but allow-major=false."
              exit 1
            fi
          elif [ "$HAS_FEAT" = "true" ]; then
            MINOR=$((MINOR+1)); PATCH=0; BUMP_TYPE=minor
          elif [ "$HAS_PATCH" = "true" ]; then
            PATCH=$((PATCH+1)); BUMP_TYPE=patch
          else
            PATCH=$((PATCH+1)); BUMP_TYPE=patch
          fi

          NEXT_VER="${MAJOR}.${MINOR}.${PATCH}"
          NEXT_TAG="v${NEXT_VER}"
          DATE_UTC=$(date -u +"%Y-%m-%d")

          ADDED=$(cat .changelog_added.txt || true)
          FIXED=$(cat .changelog_fixed.txt || true)
          BREAKING=$(cat .changelog_breaking.txt || true)

          CHANGELOG_FRAGMENT="## ${NEXT_TAG} - ${DATE_UTC}\n"
          [ -n "$ADDED"    ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Added\n${ADDED}\n"
          [ -n "$FIXED"    ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Fixed\n${FIXED}\n"
          [ -n "$BREAKING" ] && CHANGELOG_FRAGMENT="${CHANGELOG_FRAGMENT}### Breaking\n${BREAKING}\n"

          echo "$NEXT_VER" > "$VERSION_FILE"
          if [ -f CHANGELOG.md ]; then
            (printf "%b\n\n" "$CHANGELOG_FRAGMENT"; cat CHANGELOG.md) > CHANGELOG.new && mv CHANGELOG.new CHANGELOG.md
          else
            printf "%b\n" "$CHANGELOG_FRAGMENT" > CHANGELOG.md
          fi

          git add "$VERSION_FILE" CHANGELOG.md
          git commit -m "chore(release): ${NEXT_TAG}"

          REL_BRANCH_CANDIDATE="release/${NEXT_TAG}"
          git branch -f "$REL_BRANCH_CANDIDATE" HEAD
          git push -fu origin "$REL_BRANCH_CANDIDATE"

          # Prepare fragment for outputs
          printf "%s" "$CHANGELOG_FRAGMENT" | sed ':a;N;$!ba;s/\n/\\n/g' > .frag.out

          # Stash computed values for next step
          echo "NEXT_VER=$NEXT_VER" >> $GITHUB_ENV
          echo "NEXT_TAG=$NEXT_TAG" >> $GITHUB_ENV

      # Outputs are written here, before PR work
      - name: Emit outputs
        id: emit
        shell: bash
        run: |
          set -euo pipefail
          echo "version=${NEXT_VER}"                         >> "$GITHUB_OUTPUT"
          echo "tag=${NEXT_TAG}"                             >> "$GITHUB_OUTPUT"
          echo "changelog_fragment=$(cat .frag.out)"         >> "$GITHUB_OUTPUT"

      # Best-effort cosmetics: label + PR — won't break the job
      - name: Ensure 'release' label exists (best-effort)
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          gh label list --limit 200 --json name -q '.[] | select(.name=="release")' | grep -q release || \
            gh label create "release" --color "0366d6" --description "Automated release PRs"

      - name: Open/Update PR (best-effort)
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          REL_BRANCH="${{ inputs.release-branch }}"
          BR="release/${NEXT_TAG}"
          printf "%b" "$(cat .frag.out | sed 's/\\n/\n/g')" > .release-notes-fragment.md

          if gh pr view "$BR" >/dev/null 2>&1; then
            gh pr edit "$BR" --title "chore(release): ${NEXT_TAG}" --body-file .release-notes-fragment.md || true
            gh pr edit "$BR" --add-label release || true
          else
            gh pr create --head "$BR" --base "$REL_BRANCH" \
              --title "chore(release): ${NEXT_TAG}" --body-file .release-notes-fragment.md || true
            gh pr edit "$BR" --add-label release || true
          fi