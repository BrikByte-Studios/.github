# BrikByteOS Pipelines — Reusable Kaniko Build & Push Workflow
#
# Purpose:
#   - Build and push container images using Kaniko (daemonless) from CI.
#   - Standardize image naming, tagging, authentication, and caching.
#   - Provide a stable foundation for downstream deploy workflows and
#     supply-chain governance (SBOM/signing later).
#
# Key Features:
#   - Exposed as a reusable workflow via `workflow_call`.
#   - Accepts configurable image name, Dockerfile path, context, and tags.
#   - Supports additional build args for runtime-specific builds.
#   - Supports registry authentication + Kaniko image caching.
#   - Assumes GHCR by default but can be adapted to other registries.
#
# NOTE:
#   - Tags can be passed either as comma-separated ("v1.0.0,sha-abc123")
#     or as newline-separated list. This workflow normalizes both.

name: "CI — Kaniko Build & Push (Reusable)"

on:
  workflow_call:
    inputs:
      image_name:
        description: >
          Fully qualified image name, e.g. ghcr.io/brikbyte-studios/my-app.
          This should NOT include the tag; tags are provided via `tags` input.
        required: true
        type: string

      dockerfile:
        description: >
          Path to the Dockerfile relative to the repo root.
          Must be inside the build context.
        required: false
        default: ./Dockerfile
        type: string

      context:
        description: >
          Build context path (directory) to send to Kaniko.
        required: false
        default: .
        type: string

      tags:
        description: >
          Desired image tags.
          - Recommended: comma-separated, e.g. "v1.0.0,sha-${GITHUB_SHA}"
          - Also supports newline-separated list.
          These will be combined with `image_name` to produce full destinations:
            <image_name>:<tag>
        required: true
        type: string

      build_args:
        description: >
          Optional Docker build arguments (multiline string).
          Example:
            NODE_ENV=production
            API_BASE_URL=https://api.example.com
        required: false
        default: ""
        type: string

      registry:
        description: >
          Registry hostname for login. Default is ghcr.io.
          Typically inferred from image_name, but this allows overriding
          for non-GHCR registries.
        required: false
        default: ghcr.io
        type: string

      cache_enabled:
        description: >
          Whether Kaniko caching should be enabled.
          When true, Kaniko will re-use previously built layers.
        required: false
        default: true
        type: boolean

      cache_repo:
        description: >
          Optional explicit cache repository.
          If empty, a default of "<image_name>-cache" will be used.
          Example:
            ghcr.io/brikbyte-studios/cache/example-node-api
        required: false
        default: ""
        type: string

    secrets:
      REGISTRY_TOKEN:
        description: >
          Token used to authenticate to the target registry.
          For GHCR, the caller workflow can map its secrets.GITHUB_TOKEN
          or a PAT with "packages: write" scope.
        required: true
      REGISTRY_USERNAME:
        description: >
          Optional username for the registry.
          If omitted, github.actor will be used (suitable for GHCR).
        required: false

jobs:
  kaniko-build-and-push:
    name: "Kaniko — Build & Push"
    runs-on: ubuntu-latest

    steps:
      # -------------------------------------------------------------------
      # 1) Checkout the current repo so Kaniko can see Dockerfile + context
      # -------------------------------------------------------------------
      - name: "Checkout repository"
        uses: actions/checkout@v4

      # -------------------------------------------------------------------
      # 2) Normalize tags into a newline-separated list.
      #
      #    Input examples:
      #      "v1.0.0,sha-abc123"
      #      "v1.0.0\nsha-abc123"
      #
      #    Output (steps.prepare-tags.outputs.tags):
      #      v1.0.0
      #      sha-abc123
      # -------------------------------------------------------------------
      - name: "Prepare tag list for Kaniko"
        id: prepare-tags
        shell: bash
        run: |
          set -euo pipefail

          raw_tags="${{ inputs.tags }}"

          echo "Raw tags input:"
          printf '%s\n' "$raw_tags"

          # Strip spaces to make comma-separated input more robust.
          tags_no_spaces="${raw_tags// /}"

          # Replace commas with literal '\n' sequences.
          tags_with_escapes="${tags_no_spaces//,/\\n}"

          echo "Normalized tags (with \\n escapes):"
          printf '%s\n' "$tags_with_escapes"

          {
            echo "tags<<EOF"
            # -e so '\n' becomes actual newlines.
            echo -e "$tags_with_escapes"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # 3) Build full image destinations (image_name:tag).
      #
      #    Input  (prepare-tags):
      #      v1.0.0
      #      sha-abc123
      #
      #    Output (prepare-destinations.outputs.tags):
      #      ghcr.io/org/app:v1.0.0
      #      ghcr.io/org/app:sha-abc123
      # -------------------------------------------------------------------
      - name: "Build full image destinations for Kaniko"
        id: prepare-destinations
        shell: bash
        run: |
          set -euo pipefail

          image_name="${{ inputs.image_name }}"
          echo "Base image name: ${image_name}"

          echo "Raw tags to convert:"
          printf '%s\n' "${{ steps.prepare-tags.outputs.tags }}"

          full_destinations=""
          while IFS= read -r tag; do
            # Skip empty lines just in case
            if [ -z "$tag" ]; then
              continue
            fi
            full="${image_name}:${tag}"
            echo " -> ${full}"
            full_destinations="${full_destinations}${full}\n"
          done <<< "${{ steps.prepare-tags.outputs.tags }}"

          {
            echo "tags<<EOF"
            echo -e "$full_destinations"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # 4) Compute cache repository.
      #
      #    - If caller passes cache_repo input:
      #        use that directly.
      #    - Else:
      #        derive "<image_name>-cache" as the default cache repo.
      #
      #    Output:
      #      steps.prepare-cache.outputs.cache_repo
      # -------------------------------------------------------------------
      - name: "Prepare cache repository"
        id: prepare-cache
        shell: bash
        run: |
          set -euo pipefail

          image_name="${{ inputs.image_name }}"
          explicit_cache="${{ inputs.cache_repo }}"

          if [ -n "$explicit_cache" ]; then
            cache_repo="$explicit_cache"
            echo "Using explicit cache repo: $cache_repo"
          else
            cache_repo="${image_name}-cache"
            echo "Using derived cache repo: $cache_repo"
          fi

          {
            echo "cache_repo=$cache_repo"
          } >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # 5) Login to the container registry using docker/login-action
      #
      #    - Default registry: ghcr.io
      #    - Username: REGISTRY_USERNAME secret if provided, else github.actor
      #    - Password: REGISTRY_TOKEN secret
      #
      #    SECURITY:
      #      - Do NOT echo tokens or usernames.
      #      - docker/login-action masks secrets automatically.
      # -------------------------------------------------------------------
      - name: "Login to container registry"
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME != '' && secrets.REGISTRY_USERNAME || github.actor }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      # -------------------------------------------------------------------
      # 6) Kaniko build & push (with caching).
      #
      #    - Uses int128/kaniko-action (wrapper around Kaniko executor).
      #    - Builds image from context + Dockerfile.
      #    - Pushes <image_name>:<tag> for each tag.
      #    - Enables caching when cache_enabled is true.
      #
      #    Output:
      #      steps.kaniko.outputs.digest -> image digest (sha256:...)
      # -------------------------------------------------------------------
      - name: "Build & push image with Kaniko"
        id: kaniko
        uses: int128/kaniko-action@v1
        with:
          # Build context and Dockerfile
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}

          # Push image to the registry
          push: true

          # Full image destinations (image_name:tag)
          tags: |
            ${{ steps.prepare-destinations.outputs.tags }}

          # Enable/disable cache
          cache: ${{ inputs.cache_enabled }}

          # Cache repository: explicit or derived "<image_name>-cache"
          cache-repository: ${{ steps.prepare-cache.outputs.cache_repo }}

          # Optional build arguments (may be empty)
          build-args: |
            ${{ inputs.build_args }}

      # -------------------------------------------------------------------
      # 7) Post-build summary + SBOM placeholder.
      #
      #    - Writes a short summary to the job summary.
      #    - Exposes a hook for future SBOM & manifest integration.
      # -------------------------------------------------------------------
      - name: "Summarize Kaniko build & SBOM hook (TODO)"
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          echo "### Kaniko Build Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Image Name: \`${{ inputs.image_name }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Registry: \`${{ inputs.registry }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Cache Enabled: \`${{ inputs.cache_enabled }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Cache Repo: \`${{ steps.prepare-cache.outputs.cache_repo }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Logical Tags (as passed by caller):" >> "$GITHUB_STEP_SUMMARY"
          while IFS= read -r tag; do
            [ -n "$tag" ] && echo "  - \`${tag}\`" >> "$GITHUB_STEP_SUMMARY"
          done <<< "${{ steps.prepare-tags.outputs.tags }}"

          if [ -n "${{ steps.kaniko.outputs.digest }}" ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "- Image Digest: \`${{ steps.kaniko.outputs.digest }}\`" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "#### SBOM / Manifest Integration (TODO)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Future work: generate SBOM and upload as artifact." >> "$GITHUB_STEP_SUMMARY"
          echo "- Future work: persist image digest in .audit bundle." >> "$GITHUB_STEP_SUMMARY"
