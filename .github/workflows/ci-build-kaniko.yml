# BrikByteOS Pipelines — Reusable Kaniko Build & Push Workflow
#
# Purpose:
#   - Build and push container images using Kaniko (daemonless) from CI.
#   - Standardize image naming, tagging, and error handling across repos.
#   - Provide a stable foundation for downstream deploy workflows and
#     supply-chain governance (SBOM/signing later).
#
# Key Features:
#   - Exposed as a reusable workflow via `workflow_call`.
#   - Accepts configurable image name, Dockerfile path, context, and tags.
#   - Supports additional build args for runtime-specific builds.
#   - Assumes GHCR by default but can be adapted to other registries.
#   - Uses int128/kaniko-action under the hood (Kaniko wrapper).
#
# NOTE:
#   - Tags can be passed either as comma-separated ("v1.0.0,sha-abc123")
#     or as newline-separated list. This workflow normalizes both
#     into the multiline format required by the Kaniko action.

name: "CI — Kaniko Build & Push (Reusable)"

on:
  workflow_call:
    inputs:
      image_name:
        description: >
          Fully qualified image name, e.g. ghcr.io/brikbyte-studios/my-app.
          This should NOT include the tag; tags are provided via `tags` input.
        required: true
        type: string
      dockerfile:
        description: >
          Path to the Dockerfile relative to the repo root.
          Must be inside the build context.
        required: false
        default: ./Dockerfile
        type: string
      context:
        description: >
          Build context path (directory) to send to Kaniko.
        required: false
        default: .
        type: string
      tags:
        description: >
          Desired image tags.
          - Recommended: comma-separated, e.g. "v1.0.0,sha-<GITHUB_SHA>"
          - Also supports newline-separated list.
          These will be combined with `image_name` to produce full destinations:
            <image_name>:<tag>
        required: true
        type: string
      build_args:
        description: >
          Optional Docker build arguments (multiline string).
          Example:
            NODE_ENV=production
            API_BASE_URL=https://api.example.com
        required: false
        default: ""
        type: string
      registry:
        description: >
          Registry hostname for login. Default is ghcr.io.
          Typically inferred from image_name, but this allows overriding
          for non-GHCR registries.
        required: false
        default: ghcr.io
        type: string
    secrets:
      REGISTRY_TOKEN:
        description: >
          Token used to authenticate to the target registry.
          For GHCR, the caller workflow can pass its GITHUB_TOKEN secret,
          for example:
            REGISTRY_TOKEN: (caller workflow maps its secrets.GITHUB_TOKEN here)
        required: true

jobs:
  kaniko-build-and-push:
    name: "Kaniko — Build & Push"
    runs-on: ubuntu-latest

    steps:
      # -------------------------------------------------------------------
      # 1) Checkout the current repo so Kaniko can see Dockerfile + context
      # -------------------------------------------------------------------
      - name: "Checkout repository"
        uses: actions/checkout@v4

      # -------------------------------------------------------------------
      # 2) Normalize tags into a newline-separated list
      #
      #    - If the caller passed "v1.0.0,sha-abc123",
      #      we convert to:
      #         v1.0.0
      #         sha-abc123
      #
      #    - If the caller passed a multiline list already,
      #      the transformation still works safely.
      #
      #    Output:
      #      steps.prepare-tags.outputs.tags  -> multiline list of tags
      # -------------------------------------------------------------------
      - name: "Prepare tag list for Kaniko"
        id: prepare-tags
        shell: bash
        run: |
          set -euo pipefail

          # Raw input from workflow_call.
          raw_tags="${{ inputs.tags }}"

          echo "Raw tags input:"
          printf '%s\n' "$raw_tags"

          # Strip spaces to make comma-separated input more robust.
          # (Newlines are preserved.)
          tags_no_spaces="${raw_tags// /}"

          # Replace commas with literal '\n' sequences.
          tags_with_escapes="${tags_no_spaces//,/\\n}"

          echo "Normalized tags (with \\n escapes):"
          printf '%s\n' "$tags_with_escapes"

          # Emit as multiline output for downstream `with: tags`.
          {
            echo "tags<<EOF"
            # -e is required so that '\n' becomes real newlines.
            echo -e "$tags_with_escapes"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # 3) Login to the container registry using docker/login-action
      #
      #    - Default registry: ghcr.io
      #    - Username: GitHub actor (works for GHCR with GITHUB_TOKEN)
      #    - Password: REGISTRY_TOKEN secret passed by caller.
      #
      #    For non-GHCR registries:
      #      - Ensure REGISTRY_TOKEN is a valid credential for the actor.
      # -------------------------------------------------------------------
      - name: "Login to container registry"
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      # -------------------------------------------------------------------
      # 4) Kaniko build & push
      #
      #    Implementation:
      #      - Uses int128/kaniko-action (wrapper around Kaniko executor).
      #      - Builds the image from the given context + Dockerfile.
      #      - Pushes image_name:<tag> for each tag in the list.
      #
      #    Notes:
      #      - `context` and `file` are relative to the repo root.
      #      - `tags` must be newline-separated; we pass the prepared value.
      #      - `build-args` is optional; can be an empty string.
      #
      #    Output:
      #      steps.kaniko.outputs.digest -> image digest (sha256:...)
      # -------------------------------------------------------------------
      - name: "Build & push image with Kaniko"
        id: kaniko
        uses: int128/kaniko-action@v1
        with:
          # Where Kaniko should look for Docker context (source tree)
          context: ${{ inputs.context }}

          # Dockerfile path (inside context)
          file: ${{ inputs.dockerfile }}

          # True = push image to remote registry
          push: true

          # Multiline list of tags (e.g. v1.0.0, sha-<short-sha>)
          tags: |
            ${{ steps.prepare-tags.outputs.tags }}

          # Optional build arguments (may be empty)
          build-args: |
            ${{ inputs.build_args }}

          # IMPORTANT:
          # We rely on docker/login-action above to create ~/.docker/config.json.
          # int128/kaniko-action will mount this config into the Kaniko executor,
          # enabling it to authenticate to the registry.

      # -------------------------------------------------------------------
      # 5) Post-build summary + SBOM placeholder
      #
      #    - Writes a short human-readable summary to the job summary.
      #    - Exposes a clear TODO hook for later SBOM & manifest integration.
      # -------------------------------------------------------------------
      - name: "Summarize Kaniko build & SBOM hook (TODO)"
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          echo "### Kaniko Build Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Image Name: \`${{ inputs.image_name }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Registry: \`${{ inputs.registry }}\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- Tags:" >> "$GITHUB_STEP_SUMMARY"
          while IFS= read -r tag; do
            [ -n "$tag" ] && echo "  - \`${tag}\`" >> "$GITHUB_STEP_SUMMARY"
          done <<< "${{ steps.prepare-tags.outputs.tags }}"

          # If the Kaniko step ran, expose the digest for downstream consumers.
          if [ -n "${{ steps.kaniko.outputs.digest }}" ]; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "- Image Digest: \`${{ steps.kaniko.outputs.digest }}\`" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "#### SBOM / Manifest Integration (TODO)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Future work: generate SBOM and upload as artifact." >> "$GITHUB_STEP_SUMMARY"
          echo "- Future work: persist image digest in .audit bundle." >> "$GITHUB_STEP_SUMMARY"

          # Placeholder for future SBOM step:
          #   e.g., run syft or cosign to generate SBOM/signature.
          #
          #   Example (pseudo-code):
          #     syft ${{ inputs.image_name }}@${{ steps.kaniko.outputs.digest }} -o json > sbom.json
          #     upload-artifact: sbom.json
