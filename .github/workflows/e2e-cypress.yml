# Reusable Cypress E2E workflow for BrikByteOS.
#
# Responsibilities:
# - Run Cypress E2E in CI using the official Cypress Docker image.
# - Optionally start the UI under test via Docker (built from service_workdir/Dockerfile).
# - Accept base URL via env (CYPRESS_BASE_URL / E2E_TARGET_URL).
# - Wait for service readiness before executing tests.
# - Capture screenshots & videos on failure and export as artifacts.
# - Work fully offline (no Cypress Cloud).
#
# Usage (from a product repo):
#   jobs:
#     e2e-cypress:
#       uses: BrikByte-Studios/.github/.github/workflows/e2e-cypress.yml@main
#       with:
#         target_url: "http://localhost:3000"
#         health_path: "/health"
#         service_workdir: "node-ui-example"
#         cypress_image: "cypress/included:13.12.0"
#         start_with_docker: true
#         docker_image_name: "node-ui-example-app"

name: "E2E - Cypress (Reusable)"

on:
  workflow_call:
    inputs:
      target_url:
        description: "Base URL for E2E tests (e.g. https://staging.example.com, or http://localhost:3000)"
        type: string
        required: false
        default: "https://staging.example.com"
      health_path:
        description: "Relative health path used for readiness checks (e.g. /health or /)"
        type: string
        required: false
        default: "/health"
      service_workdir:
        description: "Working directory for the service under test (e.g. node-ui-example)"
        type: string
        required: false
        default: "."
      cypress_image:
        description: "Official Cypress Docker image tag to use."
        type: string
        required: false
        default: "cypress/included:13.12.0"
      spec_pattern:
        description: "Override Cypress spec filter (e.g. tests/e2e/cypress/e2e/**/*.cy.ts)"
        type: string
        required: false
        default: ""
      run_mode_retries:
        description: "Number of retries in CI (runMode)."
        type: number
        required: false
        default: 2
      open_mode_retries:
        description: "Number of retries when running locally via Cypress open (openMode)."
        type: number
        required: false
        default: 0
      artifact_name:
        description: "Artifact base name for Cypress outputs."
        type: string
        required: false
        default: "cypress-artifacts"
      start_with_docker:
        description: "If true, build & run the app via Docker before tests."
        type: boolean
        required: false
        default: false
      docker_image_name:
        description: "Docker image name to build & run when start_with_docker=true."
        type: string
        required: false
        default: "brikbyte-e2e-app"

jobs:
  cypress-e2e:
    name: "Cypress E2E"
    runs-on: ubuntu-latest

    env:
      # Base URL is passed into Cypress via env (CYPRESS_BASE_URL).
      CYPRESS_BASE_URL: ${{ inputs.target_url }}
      E2E_TARGET_URL: ${{ inputs.target_url }}
      CYPRESS_RUN_MODE_RETRIES: ${{ inputs.run_mode_retries }}
      CYPRESS_OPEN_MODE_RETRIES: ${{ inputs.open_mode_retries }}

    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # -------------------------------------------------------------
      # Optional: build & start the UI app via Docker
      # -------------------------------------------------------------
      - name: "Build UI Docker image"
        if: ${{ inputs.start_with_docker }}
        working-directory: ${{ inputs.service_workdir }}
        env:
          DOCKER_IMAGE_NAME: ${{ inputs.docker_image_name }}
        run: |
          echo "[CYPRESS-E2E] Building UI image '${DOCKER_IMAGE_NAME}' from ${PWD}/Dockerfile"
          docker build -t "${DOCKER_IMAGE_NAME}" -f Dockerfile .

      - name: "Start UI Docker container"
        if: ${{ inputs.start_with_docker }}
        env:
          DOCKER_IMAGE_NAME: ${{ inputs.docker_image_name }}
          CYPRESS_BASE_URL: ${{ env.CYPRESS_BASE_URL }}
        run: |
          echo "[CYPRESS-E2E] Starting UI container from image '${DOCKER_IMAGE_NAME}'..."
          # NOTE: We map container :3000 to host :3000 so target_url=http://localhost:3000 works.
          docker run -d --rm \
            --name "${DOCKER_IMAGE_NAME}-ctr" \
            -e PORT=3000 \
            -p 3000:3000 \
            "${DOCKER_IMAGE_NAME}"

          echo "[CYPRESS-E2E] Container '${DOCKER_IMAGE_NAME}-ctr' started."

      # -------------------------------------------------------------
      # Service readiness check (works with or without Docker)
      # -------------------------------------------------------------
      - name: "Wait for service readiness"
        env:
          HEALTH_URL: ${{ inputs.target_url }}${{ inputs.health_path }}
        run: |
          echo "[CYPRESS-E2E] Waiting for service to be ready at: ${HEALTH_URL}"

          timeout_seconds=120
          sleep_interval=5
          elapsed=0

          while ! curl -sSf "${HEALTH_URL}" > /dev/null 2>&1; do
            echo "[CYPRESS-E2E] Service not ready yet... (${elapsed}s elapsed)"
            sleep "${sleep_interval}"
            elapsed=$((elapsed + sleep_interval))

            if [ "${elapsed}" -ge "${timeout_seconds}" ]; then
              echo "[CYPRESS-E2E] ERROR: Service did not become ready within ${timeout_seconds}s."
              # If we started a Docker container, dump logs for debugging
              if [ "${{ inputs.start_with_docker }}" = "true" ]; then
                echo "[CYPRESS-E2E] Dumping Docker logs..."
                docker logs "${{ inputs.docker_image_name }}-ctr" || true
              fi
              exit 1
            fi
          done

          echo "[CYPRESS-E2E] Service is healthy at ${HEALTH_URL}."

      # -------------------------------------------------------------
      # Run Cypress E2E via official Docker image
      # -------------------------------------------------------------
      - name: "Run Cypress E2E via official Docker image"
        working-directory: ${{ inputs.service_workdir }}
        env:
          CYPRESS_IMAGE: ${{ inputs.cypress_image }}
        run: |
          echo "[CYPRESS-E2E] Using Cypress image: ${CYPRESS_IMAGE}"
          echo "[CYPRESS-E2E] Base URL: ${CYPRESS_BASE_URL}"
          echo "[CYPRESS-E2E] RunMode retries: ${CYPRESS_RUN_MODE_RETRIES}"
          echo "[CYPRESS-E2E] OpenMode retries: ${CYPRESS_OPEN_MODE_RETRIES}"

          SPEC_ARG=""
          # If a spec pattern was provided, pass it to Cypress.
          if [ -n "${{ inputs.spec_pattern }}" ]; then
            SPEC_ARG="--spec '${{ inputs.spec_pattern }}'"
            echo "[CYPRESS-E2E] Using spec filter: $SPEC_ARG"
          fi

          docker run --rm \
            -e CYPRESS_BASE_URL="${CYPRESS_BASE_URL}" \
            -e E2E_TARGET_URL="${E2E_TARGET_URL}" \
            -e CYPRESS_RUN_MODE_RETRIES="${CYPRESS_RUN_MODE_RETRIES}" \
            -e CYPRESS_OPEN_MODE_RETRIES="${CYPRESS_OPEN_MODE_RETRIES}" \
            -v "$PWD:/e2e" \
            -w /e2e \
            "${CYPRESS_IMAGE}" \
            /bin/bash -lc "npx cypress run --config-file cypress.config.ts ${SPEC_ARG}"

      # -------------------------------------------------------------
      # Upload Cypress artifacts (screenshots + videos)
      # -------------------------------------------------------------
      - name: "Upload Cypress artifacts"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: |
            tests/e2e/cypress/screenshots
            tests/e2e/cypress/videos
          if-no-files-found: "ignore"
          compression-level: 6
          overwrite: false
          include-hidden-files: false

      # -------------------------------------------------------------
      # Cleanup Docker container (if we started one)
      # -------------------------------------------------------------
      - name: "Stop UI Docker container"
        if: always() && inputs.start_with_docker
        env:
          DOCKER_IMAGE_NAME: ${{ inputs.docker_image_name }}
        run: |
          echo "[CYPRESS-E2E] Stopping UI container '${DOCKER_IMAGE_NAME}-ctr'..."
          docker ps -a || true
          docker stop "${DOCKER_IMAGE_NAME}-ctr" || true
