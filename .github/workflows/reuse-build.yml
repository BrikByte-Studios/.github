name: Reuse â€¢ Build Artifact & Container Image

on:
  workflow_call:
    inputs:
      language:
        type: string
        required: true
        description: "node | python | java"
      cache-key:
        type: string
        required: false
        default: ""
        description: "Hint for cache grouping (branch name / PR number)"
      image-name:
        type: string
        required: true
        description: "Container image name, e.g. ghcr.io/brikbytes/brikbyteos-sample-service"
      tag:
        type: string
        required: false
        default: "${{ github.sha }}"
        description: "Image tag to stamp into the container (usually commit SHA)"
      build-context:
        type: string
        required: false
        default: "."
        description: "Docker build context (usually repo root)."
      dockerfile:
        type: string
        required: false
        default: "Dockerfile"
        description: "Path to Dockerfile relative to repo root"
    secrets:
      token:
        required: false
        description: "Optional PAT for private registries / packages if needed"

jobs:
  build:
    name: build-and-package
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write  # needed if we ever push to GHCR in future evolutions

    steps:
      # -------------------------------------------------
      # 0. Capture start time for perf / audit
      # -------------------------------------------------
      - name: Capture build start time
        id: startclock
        shell: bash
        run: |
          echo "BUILD_START=$(date +%s)" >> $GITHUB_ENV

      # -------------------------------------------------
      # 1. Checkout source
      # -------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # if you ever need submodules or a full history for versioning,
          # configure it here
          fetch-depth: 0

      # -------------------------------------------------
      # 2. Setup language toolchain
      #    We only install what we need for the given service
      # -------------------------------------------------
      - name: Setup Node
        if: ${{ inputs.language == 'node' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        if: ${{ inputs.language == 'python' }}
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Java
        if: ${{ inputs.language == 'java' }}
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      # -------------------------------------------------
      # 3. Cache dependencies
      #    One cache config that covers node_modules / pip / maven
      #    We hash lockfiles to get reproducible warm builds
      # -------------------------------------------------
      - name: Cache deps
        uses: actions/cache@v4
        with:
          path: |
            **/node_modules
            ~/.cache/pip
            ~/.m2/repository
          key: ${{ runner.os }}-${{ inputs.language }}-${{ hashFiles('**/package-lock.json','**/pnpm-lock.yaml','**/requirements*.txt','**/poetry.lock','**/pom.xml') }}-${{ inputs.cache-key }}
          restore-keys: |
            ${{ runner.os }}-${{ inputs.language }}-
            ${{ runner.os }}-

      # -------------------------------------------------
      # 4. Install deps + BUILD the app (compile / bundle / package)
      #    - This is our "does it build?" gate.
      #    - We DO NOT run tests here anymore. Tests will run downstream in ci-test.
      # -------------------------------------------------
      - name: Install & Build App
        id: build_app
        shell: bash
        run: |
          set -euo pipefail

          case "${{ inputs.language }}" in
            node)
              # install
              if [ -f package-lock.json ]; then
                npm ci --no-audit --no-fund
              else
                npm i --package-lock-only --no-audit --no-fund
                npm ci --no-audit --no-fund
              fi
              # build (assumes npm run build outputs compiled code to dist/)
              npm run build || true
              ;;
            python)
              python -m pip install --upgrade pip
              # if requirements.txt exists, install it
              if [ -f requirements.txt ]; then
                pip install -r requirements.txt
              fi
              # sanity compile (fail fast on syntax errors)
              python -m py_compile $(git ls-files '*.py') || true
              ;;
            java)
              # mvn install w/ tests ON to ensure it actually compiles under test conditions,
              # but you can use -DskipTests if you want build-only here.
              mvn -q -B clean package -DskipTests=false
              ;;
            *)
              echo "Unsupported language '${{ inputs.language }}'" >&2
              exit 1
              ;;
          esac

      # -------------------------------------------------
      # 5. Prep build_artifacts dir BEFORE buildx writes image.tar
      #   
      # -------------------------------------------------
      - name: Ensure build_artifacts dir exists
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_artifacts

      # -------------------------------------------------
      # 6. Prepare Docker buildx
      #    We will build the container image ONCE here,
      #    and hand it off to later jobs (test / deploy) as an artifact.
      # -------------------------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      

      # -------------------------------------------------
      # 7. Build image ONCE, with cache, export to tar
      #    Note:
      #      - cache-from/to: gha for warm reuse
      #      - outputs: type=docker,dest=build_artifacts/image.tar
      #        (requires build_artifacts/ to already exist)
      #    We do NOT push here.
      # -------------------------------------------------
      - name: Build container image (cached, no push)
        id: build_image
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs['build-context'] }}
          file: ${{ inputs.dockerfile }}
          push: false
          tags: ${{ inputs['image-name'] }}:${{ inputs.tag }}

          # Enable GHA-backed layer cache
          cache-from: type=gha
          cache-to: type=gha,mode=max

          # Export an OCI-compatible docker image tar we can reuse later
          outputs: type=docker,dest=build_artifacts/image.tar

      # -------------------------------------------------
      # 8. Archive build outputs (dist/, target/, etc.)
      #    We also capture build_artifacts/ for downstream scan + debug.
      # -------------------------------------------------
      - name: Archive service build artifacts
        id: archive_artifacts
        shell: bash
        run: |
          set -euo pipefail

          # ensure dir still exists
          mkdir -p build_artifacts

          # Capture "the thing we'd ship", language-aware
          if [ "${{ inputs.language }}" = "node" ] && [ -d dist ]; then
            tar -czf build_artifacts/service-dist.tar.gz dist
          elif [ "${{ inputs.language }}" = "java" ] && [ -d target ]; then
            tar -czf build_artifacts/service-dist.tar.gz target
          elif [ "${{ inputs.language }}" = "python" ]; then
            # Python services often don't have a compiled dist,
            # so capture source + requirements for review / SCA
            tar -czf build_artifacts/service-dist.tar.gz *.py requirements.txt 2>/dev/null || true
          else
            # fallback: best-effort capture of repo contents
            tar -czf build_artifacts/service-dist.tar.gz . 2>/dev/null || true
          fi

      # -------------------------------------------------
      # 9. Capture timing + cache audit
      #    We write build-metrics.json which ci-deploy.yml will embed
      #    into .audit/<env>/<date>/deploy.json for traceability.
      #
      #    TODO for future hardening:
      #      - detect actual "cache hit" vs "miss" from logs and set booleans.
      # -------------------------------------------------
      - name: Capture build end time & metrics
        id: perf
        shell: bash
        run: |
          set -euo pipefail
          END=$(date +%s)
          DURATION=$((END - BUILD_START))

          # basic stub flags for now (PIPE-CICD-BUILD-003 can parse logs for real hit/miss)
          LANG_CACHE_HIT=true
          DOCKER_LAYER_CACHE_HIT=true

          cat > build_artifacts/build-metrics.json <<EOF
          {
            "start_unix": $BUILD_START,
            "end_unix": $END,
            "duration_sec": $DURATION,
            "language_cache_hit": $LANG_CACHE_HIT,
            "docker_layer_cache_hit": $DOCKER_LAYER_CACHE_HIT,
            "image_name": "${{ inputs['image-name'] }}",
            "image_tag": "${{ inputs.tag }}",
            "commit_sha": "${GITHUB_SHA}",
            "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF

          echo "build-metrics.json:"
          cat build_artifacts/build-metrics.json

      # -------------------------------------------------
      # 10. Upload artifacts for downstream jobs
      #    a) service-build-artifacts       -> dist/, target/, etc.
      #    b) service-container-image       -> built image tar we will push in deploy
      #    c) build-metrics                 -> perf + cache audit
      # -------------------------------------------------
      - name: Upload compiled artifacts
        uses: actions/upload-artifact@v4
        with:
          name: service-build-artifacts
          path: build_artifacts/service-dist.tar.gz
          if-no-files-found: ignore

      - name: Upload container image artifact
        uses: actions/upload-artifact@v4
        with:
          name: service-container-image
          path: build_artifacts/image.tar

      - name: Upload build metrics
        uses: actions/upload-artifact@v4
        with:
          name: build-metrics
          path: build_artifacts/build-metrics.json
          if-no-files-found: error