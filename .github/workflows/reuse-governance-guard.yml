name: Reuse - Governance Guard

on:
  workflow_call:
    inputs:
      protected-branches:
        type: string
        required: true
        description: "CSV: e.g. main,release/*"
      required-checks:
        type: string
        required: true
        description: "CSV of required status check contexts"

jobs:
  validate-and-export:
    runs-on: ubuntu-latest
    permissions:
      contents: write         # commit audit export to a branch
      pull-requests: write    # open PR with audit evidence
      actions: read           # read workflow runs if needed later
      security-events: read   # read Code Scanning if you extend checks
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Expand inputs
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          echo "BRANCHES=${{ inputs.protected-branches }}" >> "$GITHUB_OUTPUT"
          echo "CHECKS=${{ inputs.required-checks }}" >> "$GITHUB_OUTPUT"
          echo "DATE=$(date +%F)" >> "$GITHUB_OUTPUT"

      # Determine which concrete branches to validate:
      # - Expand wildcards against existing branch names.
      - name: Resolve target branches
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -ra WANT <<< "${{ steps.vars.outputs.BRANCHES }}"
          mapfile -t EXISTING < <(gh api repos/${{ github.repository }}/branches?per_page=100 | jq -r '.[].name')
          SELECTED=()
          for want in "${WANT[@]}"; do
            if [[ "$want" == *"*"* ]]; then
              pat="${want//\*/.*}"   # convert glob to regex
              for b in "${EXISTING[@]}"; do
                [[ "$b" =~ ^${pat}$ ]] && SELECTED+=("$b")
              done
            else
              SELECTED+=("$want")
            fi
          done
          printf "%s\n" "${SELECTED[@]}" | sort -u > /tmp/branches.txt
          echo "branches_file=/tmp/branches.txt" >> "$GITHUB_OUTPUT"

      - name: Validate branch protection & required checks
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          REQS="${{ steps.vars.outputs.CHECKS }}"
          IFS=',' read -ra REQUIRED <<< "$REQS"
          FAIL=0

          while read -r BR; do
            [[ -z "$BR" ]] && continue
            echo "→ Checking protection for branch: $BR"
            # Fetch protection JSON; fail if missing
            if ! gh api repos/${{ github.repository }}/branches/$BR/protection > /tmp/protect.$BR.json 2>/dev/null; then
              echo "::error title=Missing protection::Branch '$BR' is not protected"
              FAIL=1; continue
            fi

            # PR review requirements
            REQS_JSON=$(jq -r '.required_pull_request_reviews // {}' /tmp/protect.$BR.json)
            COUNT=$(jq -r '.required_approving_review_count // 0' <<<"$REQS_JSON")
            CO=$(jq -r '.require_code_owner_reviews // false' <<<"$REQS_JSON")
            if [ "$COUNT" -lt 1 ]; then
              echo "::error title=Reviewers::$BR requires at least 1 approving review"
              FAIL=1
            fi
            if [ "$CO" != "true" ]; then
              echo "::error title=Code Owners::$BR must require Code Owner reviews"
              FAIL=1
            fi

            # Required status checks include all REQUIRED
            if ! gh api repos/${{ github.repository }}/branches/$BR/protection/required_status_checks > /tmp/status.$BR.json 2>/dev/null; then
              echo "::error title=Status checks::Cannot fetch status checks for $BR"
              FAIL=1; continue
            fi
            mapfile -t CONTEXTS < <(jq -r '.contexts // [] | .[]' /tmp/status.$BR.json)
            for need in "${REQUIRED[@]}"; do
              if ! printf "%s\n" "${CONTEXTS[@]}" | grep -qx "$need"; then
                echo "::error title=Missing check::$BR is missing required status check '$need'"
                FAIL=1
              fi
            done

            # Soft checks (warn only)
            ENF=$(jq -r '.enforce_admins.enabled // false' /tmp/protect.$BR.json)
            [ "$ENF" = "true" ] || echo "::warning title=Admins::$BR should enforce admins"
            DS=$(jq -r '.required_pull_request_reviews.dismiss_stale_reviews // false' /tmp/protect.$BR.json)
            [ "$DS" = "true" ] || echo "::warning title=Dismiss stale::$BR should dismiss stale reviews"
          done < "${{ steps.resolve.outputs.branches_file }}"

          echo "fail=$FAIL" >> "$GITHUB_OUTPUT"
          exit $FAIL

      - name: Export protection JSON → .audit/
        shell: bash
        run: |
          set -euo pipefail
          D=".audit/${{ steps.vars.outputs.DATE }}"
          mkdir -p "$D"
          while read -r BR; do
            [[ -z "$BR" ]] && continue
            SAFE="${BR//\//__}"  # sanitize file name
            cp "/tmp/protect.$BR.json" "$D/branch-protection-$SAFE.json" 2>/dev/null || true
            cp "/tmp/status.$BR.json"  "$D/required-status-checks-$SAFE.json" 2>/dev/null || true
          done < "${{ steps.resolve.outputs.branches_file }}"
          ls -la "$D" || true

      - name: Determine default branch
        id: def
        shell: bash
        run: |
          set -euo pipefail
          DEF=$(gh repo view ${{ github.repository }} --json defaultBranchRef -q .defaultBranchRef.name)
          echo "default=$DEF" >> "$GITHUB_OUTPUT"

      - name: Open PR with audit evidence (create or update)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="chore/audit-branch-protection-${{ steps.vars.outputs.DATE }}"
          BASE="${{ steps.def.outputs.default }}"
          git config user.name  "brikbyte-bot"
          git config user.email "bot@users.noreply.github.com"
          git checkout -b "$BRANCH" || git checkout "$BRANCH"
          git add .audit
          if git diff --staged --quiet; then
            echo "No audit changes to commit."
          else
            git commit -m "chore(audit): update branch protection export"
            git push -u origin "$BRANCH" || true
            # If PR exists already, this will no-op gracefully
            gh pr create --base "$BASE" --title "chore(audit): branch protection export" --body "Automated export of branch protection and required status checks." || true
          fi
