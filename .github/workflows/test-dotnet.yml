# =============================================================================
# BrikByteOS ‚Äî Reusable .NET Unit Test Workflow (sharded)
# -----------------------------------------------------------------------------
# WBS ID : PIPE-TEST-UNIT-CI-BUILD-002
# Repos  :
#   - Implemented in:
#       ‚Ä¢ BrikByte-Studios/.github (.github/workflows/test-dotnet.yml)
#   - Consumed by:
#       ‚Ä¢ BrikByte-Studios/brik-pipe-examples/dotnet-api-example
#       ‚Ä¢ Product repos (via workflow_call)
#
# Contract:
#   - Expects:
#       ‚Ä¢ Makefile with `make test` calling `dotnet test`
#       ‚Ä¢ One or more test projects (e.g. /tests/SomeApp.Tests)
#
# Matrix plan integration:
#   - Uses BrikPipe Matrix Plan composite action to compute shards deterministically
#   - Parallel rules live in:
#       BrikByte-Studios/.github/.github/actions/matrix-plan/parallel-matrix.yml
#
# Shard-safe coverage:
#   - Some shards may run no tests (e.g., more shards than test projects)
#   - We detect Coverlet output presence and ONLY normalize/upload coverage when present
#   - Empty shards skip coverage steps (avoids stub coverage + failing normalizer)
# =============================================================================

name: "BrikByteOS ‚Äî .NET Unit Tests"

on:
  workflow_call:
    inputs:
      dotnet-version:
        description: ".NET SDK version (e.g. 8.0.x)"
        required: false
        type: string
        default: "8.0.x"

      working-directory:
        description: "Path to .NET solution root (Makefile + *.sln or tests/)"
        required: false
        type: string
        default: "."

      # ------------------------------
      # Governed parallelism (optional)
      # ------------------------------
      override_shards:
        description: "Optional requested shard count (clamped to caps)."
        required: false
        type: string
        default: ""

      matrix_config_path:
        description: >
          Optional path to parallel-matrix.yml.
          Leave empty to use default inside BrikByte-Studios/.github.
        required: false
        type: string
        default: ""

      parallel_mode:
        description: "Parallel mode: static|dynamic (default static)"
        required: false
        type: string
        default: "static"

permissions:
  contents: read

jobs:
  # ---------------------------------------------------------------------------
  # 0) PLAN: compute governed matrix JSON (job output)
  # ---------------------------------------------------------------------------
  plan:
    name: "Matrix Plan (.NET unit)"
    runs-on: ubuntu-latest
    outputs:
      matrix_json: ${{ steps.matrix.outputs.matrix_json }}

    steps:
      - name: "Compute matrix plan (unit)"
        id: matrix
        uses: BrikByte-Studios/.github/.github/actions/matrix-plan@main
        with:
          test_type: "unit"
          config_path: ${{ inputs.matrix_config_path }}
          override_shards: ${{ inputs.override_shards }}

      - name: "Debug matrix_json"
        run: |
          echo "matrix_json=${{ steps.matrix.outputs.matrix_json }}"

  # ---------------------------------------------------------------------------
  # 1) TEST: run shards from matrix computed in plan job
  # ---------------------------------------------------------------------------
  test:
    name: ".NET: Unit Tests ‚Ä¢ shard ${{ matrix.shard }}"
    runs-on: ubuntu-latest
    needs: plan

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.matrix_json) }}

    env:
      LANGUAGE: dotnet
      DOTNET_VERSION: ${{ inputs.dotnet-version != '' && inputs.dotnet-version || '8.0.x' }}
      WORKING_DIRECTORY: ${{ inputs.working-directory != '' && inputs.working-directory || '.' }}

      # shard metadata (deterministic)
      SHARD_INDEX: ${{ matrix.shard }}
      SHARD_TOTAL: ${{ strategy.job-total }}

      # Optional sharding contract for Makefile/test runners
      UNIT_SHARD: ${{ matrix.shard }}
      UNIT_SHARD_TOTAL: ${{ strategy.job-total }}

      PARALLEL_MODE: ${{ inputs.parallel_mode }}

      FORCE_COLOR: "0"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify .NET test layout
        run: |
          set -euo pipefail
          echo "üìÅ Working directory: ${WORKING_DIRECTORY}"

          if [ ! -d "${WORKING_DIRECTORY}" ]; then
            echo "‚ùå WORKING_DIRECTORY '${WORKING_DIRECTORY}' does not exist."
            exit 1
          fi

          cd "${WORKING_DIRECTORY}"

          # NOTE: Bash globstar isn't enabled by default; keep checks simple & reliable.
          if ! ls *.sln >/dev/null 2>&1 && ! find . -maxdepth 4 -name "*.csproj" | head -n 1 | grep -q .; then
            echo "‚ùå No .sln or .csproj files found under ${PWD}."
            exit 1
          fi

          if [ ! -f "Makefile" ]; then
            echo "‚ùå Makefile not found in ${PWD}."
            echo "   Expected 'make test' mapping to 'dotnet test'."
            exit 1
          fi

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "Cache .NET dependencies & tools"
        uses: BrikByte-Studios/.github/.github/actions/cache-dotnet-deps@main
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          project-path: ${{ env.WORKING_DIRECTORY }}

      - name: "Discover test items (unit) ‚Äî deterministic"
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail
          mkdir -p out

          # Example strategy: treat each test project as an item
          # Adjust per language (e.g., *.spec.ts for e2e, etc.)
          find . -maxdepth 5 -name "*.csproj" | sort > out/test-items.txt

          echo "Discovered $(wc -l < out/test-items.txt) items"
          head -n 20 out/test-items.txt

      - name: "Plan shards (static/dynamic) ‚Äî non-blocking"
        id: shardplan
        continue-on-error: true
        uses: BrikByte-Studios/.github/.github/actions/shard-plan@main
        with:
          mode: ${{ env.PARALLEL_MODE }}
          shard_count: ${{ env.SHARD_TOTAL }}
          test_type: "unit"
          items_file: "${{ env.WORKING_DIRECTORY }}/out/test-items.txt"
          workdir: "${{ env.WORKING_DIRECTORY }}"
          out_dir: "${{ env.WORKING_DIRECTORY }}/out"
          audit_root: ".audit"
          seed: "${{ github.sha }}" # deterministic input

      - name: "Fallback to static if shard planner failed"
        if: steps.shardplan.outcome != 'success'
        run: |
          echo "::warning::Shard planner failed; falling back to static mode."
          echo "PARALLEL_MODE=static" >> "$GITHUB_ENV"


      - name: Run .NET unit tests (make test)
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail

          echo "üß™ [TEST] Language  : ${LANGUAGE}"
          echo "üß™ [TEST] Runtime   : .NET SDK ${DOTNET_VERSION}"
          echo "üß™ [TEST] Directory : ${PWD}"
          echo "üß™ [TEST] Command   : make test"
          echo "üß™ [TEST] Shard     : ${UNIT_SHARD}/${UNIT_SHARD_TOTAL}"
          echo "üß™ [TEST] Status    : STARTING"

          START_TS=$(date +%s)

          # NOTE:
          # Your Makefile may optionally consume UNIT_SHARD / UNIT_SHARD_TOTAL.
          # If it doesn't, all shards will run the full suite (wasteful but correct).
          make test

          END_TS=$(date +%s)
          DURATION=$((END_TS - START_TS))

          echo "‚úÖ [TEST] Status    : COMPLETED"
          echo "‚è±  [TEST] Duration : ${DURATION} seconds"
          echo "‚ÑπÔ∏è  [TEST] See dotnet test summary above."

      # -----------------------------------------------------------------------
      # Detect whether this shard produced coverage (empty shard => skip coverage)
      # -----------------------------------------------------------------------
      - name: Detect coverage artifacts (per shard)
        id: covdetect
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail

          FOUND="$(find . -type f -name "coverage.net*.json" | head -n 1 || true)"
          if [ -n "$FOUND" ]; then
            echo "has_coverage=true" >> "$GITHUB_OUTPUT"
            echo "coverlet_json=$FOUND" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Found Coverlet JSON: $FOUND"
          else
            echo "has_coverage=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è No Coverlet JSON found for this shard (likely no tests ran)."
          fi

      # -----------------------------------------------------------------------
      # Coverage normalization (ONLY when coverage exists)
      # NOTE: removed coverage-merge@main here because it emits a stub for dotnet.
      # -----------------------------------------------------------------------
      - name: Ensure summary.line is set in out/coverage.json (.NET / Coverlet)
        if: steps.covdetect.outputs.has_coverage == 'true'
        working-directory: ${{ env.WORKING_DIRECTORY }}
        env:
          COVERLET_JSON: ${{ steps.covdetect.outputs.coverlet_json }}
        run: |
          set -euo pipefail
          echo "üîß Normalizing .NET coverage: syncing summary.line from Coverlet JSON"
          echo "‚ÑπÔ∏è Using Coverlet JSON: ${COVERLET_JSON}"

          python - << 'PY'
          import json, os
          from pathlib import Path

          coverlet_path = Path(os.environ["COVERLET_JSON"])
          data = json.loads(coverlet_path.read_text(encoding="utf-8"))

          def iter_lines_maps(obj):
            """
            Yield any dict that looks like a Coverlet 'Lines' map:
              { "12": 1, "13": 0, ... }
            """
            if isinstance(obj, dict):
              for k, v in obj.items():
                if k in ("Lines", "lines") and isinstance(v, dict):
                  yield v
                else:
                  yield from iter_lines_maps(v)
            elif isinstance(obj, list):
              for item in obj:
                yield from iter_lines_maps(item)

          total = 0
          covered = 0

          for lines_map in iter_lines_maps(data):
            for _, hits in lines_map.items():
              try:
                h = int(hits)
              except Exception:
                continue
              total += 1
              if h > 0:
                covered += 1

          if total <= 0:
            raise SystemExit("Cannot determine coverage: no line hit data found in Coverlet JSON (no Lines maps).")

          percent = (covered / total) * 100.0

          cov_dir = Path("out")
          cov_dir.mkdir(parents=True, exist_ok=True)
          cov_path = cov_dir / "coverage.json"

          cov = json.loads(cov_path.read_text(encoding="utf-8")) if cov_path.exists() else {}
          cov.setdefault("summary", {})
          cov["summary"]["line"] = float(percent)
          cov.setdefault("files", [])

          cov_path.write_text(json.dumps(cov, indent=2), encoding="utf-8")
          print(f"‚úÖ Updated out/coverage.json with summary.line = {percent:.2f} (covered={covered}, total={total})")
          PY

          echo "‚úÖ out/coverage.json:"
          cat out/coverage.json

      # -----------------------------------------------------------------------
      # Upload artifacts
      # - JUnit is useful even if shard was empty (but may not exist)
      # - Coverage should only upload when it exists (avoid stub artifacts)
      # -----------------------------------------------------------------------
      - name: Upload shard JUnit artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-dotnet-shard${{ env.UNIT_SHARD }}
          path: |
            ${{ env.WORKING_DIRECTORY }}/out/junit-shard${{ env.UNIT_SHARD }}.xml
            ${{ env.WORKING_DIRECTORY }}/TestResults/
          if-no-files-found: ignore

      - name: Upload shard coverage artifacts
        if: steps.covdetect.outputs.has_coverage == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-dotnet-shard${{ env.UNIT_SHARD }}
          path: |
            ${{ env.WORKING_DIRECTORY }}/out/coverage.json
            ${{ env.WORKING_DIRECTORY }}/TestResults/
          if-no-files-found: ignore
