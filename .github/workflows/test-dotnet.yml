# =============================================================================
# BrikByteOS ‚Äî Reusable .NET Unit Test Workflow
# -----------------------------------------------------------------------------
# WBS ID : PIPE-TEST-UNIT-CI-BUILD-002
# Repos  :
#   - Implemented in:
#       ‚Ä¢ BrikByte-Studios/.github (.github/workflows/test-dotnet.yml)
#   - Consumed by:
#       ‚Ä¢ BrikByte-Studios/brik-pipe-examples/dotnet-api-example
#       ‚Ä¢ Product repos (via workflow_call)
#
# Contract:
#   - Expects:
#       ‚Ä¢ Makefile with `make test` calling `dotnet test`
#       ‚Ä¢ One or more test projects (e.g. /tests/SomeApp.Tests).
# =============================================================================
name: "BrikByteOS ‚Äî .NET Unit Tests"

on:
  workflow_call:
    inputs:
      dotnet-version:
        description: ".NET SDK version (e.g. 8.0.x)"
        required: false
        type: string
        default: "8.0.x"
      working-directory:
        description: "Path to .NET solution root (Makefile + *.sln or tests/)"
        required: false
        type: string
        default: "."

permissions:
  contents: read

jobs:
  test:
    name: ".NET: Unit Tests"
    runs-on: ubuntu-latest

    env:
      LANGUAGE: dotnet
      DOTNET_VERSION: ${{ inputs.dotnet-version != '' && inputs.dotnet-version || '8.0.x' }}
      WORKING_DIRECTORY: ${{ inputs.working-directory != '' && inputs.working-directory || '.' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify .NET test layout
        run: |
          echo "üìÅ Working directory: ${WORKING_DIRECTORY}"

          if [ ! -d "${WORKING_DIRECTORY}" ]; then
            echo "‚ùå WORKING_DIRECTORY '${WORKING_DIRECTORY}' does not exist."
            exit 1
          fi

          cd "${WORKING_DIRECTORY}"

          if ! compgen -G "*.sln" > /dev/null && ! compgen -G "**/*.csproj" > /dev/null; then
            echo "‚ùå No .sln or .csproj files found in ${PWD}."
            exit 1
          fi

          if [ ! -f "Makefile" ]; then
            echo "‚ùå Makefile not found in ${PWD}."
            echo "   Expected 'make test' mapping to 'dotnet test'."
            exit 1
          fi

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "Cache .NET dependencies & tools"
        uses: BrikByte-Studios/.github/.github/actions/cache-dotnet-deps@main
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          project-path: ${{ env.WORKING_DIRECTORY }}

      - name: Run .NET unit tests (make test)
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail

          echo "üß™ [TEST] Language  : ${LANGUAGE}"
          echo "üß™ [TEST] Runtime   : .NET SDK ${DOTNET_VERSION}"
          echo "üß™ [TEST] Directory : ${PWD}"
          echo "üß™ [TEST] Command   : make test"
          echo "üß™ [TEST] Status    : STARTING"

          START_TS=$(date +%s)

          make test

          END_TS=$(date +%s)
          DURATION=$((END_TS - START_TS))

          echo "‚úÖ [TEST] Status    : COMPLETED"
          echo "‚è±  [TEST] Duration : ${DURATION} seconds"
          echo "‚ÑπÔ∏è  [TEST] See dotnet test summary above."

      # -----------------------------------------------------------------------
      # X) Collect coverage (.NET: coverlet JSON via dotnet test)
      # -----------------------------------------------------------------------
      - name: Normalize coverage ‚Üí coverage.json
        uses: BrikByte-Studios/.github/.github/actions/coverage-merge@main
        with:
          language: ${{ env.LANGUAGE }}
          working-directory: ${{ env.WORKING_DIRECTORY }}
          out: out/coverage.json

      - name: Ensure summary.line is set in coverage.json (.NET / Coverlet)
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail
          echo "üîß Normalizing .NET coverage: syncing summary.line from Coverlet JSON"

          # 1) Try common root-level location first.
          if [ -f "TestResults/coverage.net.json" ]; then
            export COVERLET_JSON="TestResults/coverage.net.json"
          elif [ -f "TestResults/coverage.net..json" ]; then
            export COVERLET_JSON="TestResults/coverage.net..json"
          else
            echo "‚ùå Coverlet JSON not found at TestResults/coverage.net*.json; searching under working directory..."
            # Search entire working directory for any coverage.net*.json
            FOUND=$(find . -type f -name "coverage.net*.json" | head -n 1 || true)
            if [ -z "$FOUND" ]; then
              echo "‚ùå No Coverlet JSON file found under working directory."
              ls -R
              exit 1
            fi
            echo "‚ÑπÔ∏è Using detected Coverlet JSON: $FOUND"
            export COVERLET_JSON="$FOUND"
          fi

          python - << 'EOF'
          import json
          import os
          from pathlib import Path
          import xml.etree.ElementTree as ET

          # -------------------------------
          # Helper: load existing coverage.json (may be stub)
          # -------------------------------
          cov_dir = Path("out")
          cov_dir.mkdir(parents=True, exist_ok=True)
          cov_path = cov_dir / "coverage.json"

          try:
            cov = json.loads(cov_path.read_text(encoding="utf-8"))
          except FileNotFoundError:
            cov = {}

          percent = None
          total = None
          covered = None

          # -------------------------------
          # Try to read percent from Coverlet JSON
          # -------------------------------
          cj = os.environ.get("COVERLET_JSON")
          if cj:
            coverlet_path = Path(cj)
            if coverlet_path.is_file():
              data = json.loads(coverlet_path.read_text(encoding="utf-8"))

              # Shape 1: top-level "Line"
              line_summary = data.get("Line")
              if isinstance(line_summary, dict):
                percent = line_summary.get("Percent")
                total = line_summary.get("Total")
                covered = line_summary.get("Covered")

              # Shape 2: "Summary": { "Line": {...} }
              if percent is None and isinstance(data.get("Summary"), dict):
                ls = data["Summary"].get("Line") or data["Summary"].get("line")
                if isinstance(ls, dict):
                  percent = ls.get("Percent") or ls.get("percent")
                  total = ls.get("Total") or ls.get("total")
                  covered = ls.get("Covered") or ls.get("covered")

              # Shape 3: "Modules": { name -> { Summary.Line } }
              modules = None
              if isinstance(data.get("Modules"), dict):
                modules = data["Modules"]

              # Shape 4: top-level assemblies map:
              #   { "SomeAssembly.dll": { ... }, ... }
              if modules is None and isinstance(data, dict):
                if all(isinstance(v, dict) for v in data.values()):
                  modules = data

              if percent is None and isinstance(modules, dict):
                t_total = 0
                t_cov = 0
                for mod_name, mod in modules.items():
                  ls = None

                  # Option A: module["Line"]
                  if isinstance(mod.get("Line"), dict):
                    ls = mod["Line"]

                  # Option B: module["Summary"]["Line"]
                  if ls is None and isinstance(mod.get("Summary"), dict):
                    cand = mod["Summary"].get("Line") or mod["Summary"].get("line")
                    if isinstance(cand, dict):
                      ls = cand

                  if isinstance(ls, dict):
                    tt = ls.get("Total") or ls.get("total")
                    cc = ls.get("Covered") or ls.get("covered")
                    if isinstance(tt, (int, float)) and isinstance(cc, (int, float)):
                      t_total += tt
                      t_cov += cc
                      continue

                  # Option C: raw "Lines": { "12": 1, "13": 0, ... }
                  lines_map = mod.get("Lines") or mod.get("lines")
                  if isinstance(lines_map, dict):
                    for _, hits in lines_map.items():
                      try:
                        h = int(hits)
                      except Exception:
                        continue
                      t_total += 1
                      if h > 0:
                        t_cov += 1

                if t_total > 0:
                  total = t_total
                  covered = t_cov
                  percent = (t_cov / t_total) * 100.0

          # -------------------------------
          # Fallback: parse OpenCover XML if percent still unknown
          # -------------------------------
          if percent is None:
            print("‚ÑπÔ∏è JSON did not yield a summary; trying OpenCover XML...")
            xml_path: Path | None = None

            # Search for coverage.net*.opencover.xml under working dir
            for p in Path(".").rglob("coverage.net*.opencover.xml"):
              xml_path = p
              break

            if xml_path and xml_path.is_file():
              tree = ET.parse(str(xml_path))
              root = tree.getroot()
              summary = root.find(".//Summary")
              if summary is not None:
                num_sp = summary.attrib.get("numSequencePoints")
                vis_sp = summary.attrib.get("visitedSequencePoints")
                try:
                  if num_sp is not None and vis_sp is not None:
                    total = int(num_sp)
                    covered = int(vis_sp)
                    if total > 0:
                      percent = covered / total * 100.0
                except ValueError:
                  pass

          # -------------------------------
          # Final: require percent to be set
          # -------------------------------
          if percent is None:
            # Last-resort debug info
            print("‚ö†Ô∏è Unable to determine coverage percent from Coverlet JSON or OpenCover XML.")
            raise SystemExit("Cannot determine coverage percent from coverage artifacts")

          cov.setdefault("summary", {})
          cov["summary"]["line"] = float(percent)
          cov.setdefault("files", [])

          cov_path.write_text(json.dumps(cov, indent=2), encoding="utf-8")
          print(f"‚úÖ Updated out/coverage.json with summary.line = {percent:.2f}")
          EOF

          echo "‚úÖ coverage.json after normalization:"
          cat out/coverage.json



      - name: Upload Dotnet coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ env.LANGUAGE }}
          path: |
            ${{ env.WORKING_DIRECTORY }}/out/coverage.json
            ${{ env.WORKING_DIRECTORY }}/TestResults/
          if-no-files-found: ignore
