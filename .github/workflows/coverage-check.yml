# =============================================================================
# BrikByteOS — Coverage Governance Gate Workflow
# -----------------------------------------------------------------------------
# Task / WBS:
#   - [TASK] GOV-TEST-COVERAGE-POLICY-004
#
# Repo:
#   - Implemented in:
#       • BrikByte-Studios/.github (.github/workflows/coverage-check.yml)
#   - Consumed by:
#       • BrikByte-Studios/brik-pipe-examples/*
#       • Product repos via workflow_call
#
# Purpose:
#   Enforce coverage thresholds (overall + critical paths) for protected branches
#   using coverage.json + .governance/tests.yml.
# =============================================================================
name: "BrikByteOS — Coverage Governance Gate"

on:
  workflow_call:
    inputs:
      working-directory:
        description: "Directory where coverage.json lives (relative to repo root)"
        required: false
        default: "."
        type: string
      coverage-file:
        description: "Path to normalized coverage.json (relative to working-directory)"
        required: false
        default: "./out/coverage.json"
        type: string
      policy-file:
        description: "Coverage policy file (relative to repo root)"
        required: false
        default: ".governance/tests.yml"
        type: string
      baseline-file:
        description: "Optional baseline coverage file (relative to repo root)."
        required: false
        default: ".audit/coverage-baseline.json"
        type: string
      coverage-artifact-name:
        description: "Name of coverage artifact uploaded by test job"
        required: false
        default: "coverage-node"
        type: string
      node-version:
        description: "Node version used to run the governance gate"
        required: false
        default: "20"
        type: string

  pull_request:
    branches:
      - main
      - "release/*"

permissions:
  contents: read

jobs:
  coverage-gate:
    name: "Coverage Governance Gate"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Download coverage artifact into a neutral folder (avoid double-nesting)
      # -----------------------------------------------------------------------
      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.coverage-artifact-name }}
          path: .artifacts/coverage

      # -----------------------------------------------------------------------
      # Materialize coverage into canonical path:
      #   <working-directory>/<coverage-file>
      # This avoids "node-api-example/node-api-example/out/coverage.json" issues.
      # -----------------------------------------------------------------------
      - name: Materialize coverage.json into working directory
        shell: bash
        run: |
          set -euo pipefail

          WD="${{ inputs.working-directory }}"
          COV_REL="${{ inputs.coverage-file }}"
          COV_REL="${COV_REL#./}"

          TARGET="${WD}/${COV_REL}"

          echo "[COVERAGE] working-directory : ${WD}"
          echo "[COVERAGE] coverage-file     : ${COV_REL}"
          echo "[COVERAGE] target            : ${TARGET}"

          echo "[COVERAGE] downloaded files:"
          find .artifacts/coverage -maxdepth 12 -type f -print || true

          # 1) If artifact already contains the exact target path, use it.
          if [[ -f ".artifacts/coverage/${TARGET}" ]]; then
            found=".artifacts/coverage/${TARGET}"
            echo "[COVERAGE] using exact target from artifact: ${found}"
          else
            # 2) Collect all possible candidates
            mapfile -t CANDS < <(find .artifacts/coverage -type f \
              \( -path "*/out/coverage.json" -o -name "coverage.json" \) -print)

            if [[ "${#CANDS[@]}" -eq 0 ]]; then
              echo "[COVERAGE] ERROR: Could not find coverage.json in downloaded artifact."
              exit 1
            fi

            echo "[COVERAGE] candidates:"
            printf "  - %s\n" "${CANDS[@]}"

            # 3) Prefer */out/coverage.json if present, else keep all
            mapfile -t OUT_CANDS < <(printf "%s\n" "${CANDS[@]}" | grep -E '/out/coverage\.json$' || true)
            if [[ "${#OUT_CANDS[@]}" -gt 0 ]]; then
              CANDS=("${OUT_CANDS[@]}")
              echo "[COVERAGE] filtered candidates (prefer out/coverage.json):"
              printf "  - %s\n" "${CANDS[@]}"
            fi

            # 4) If multiple remain, pick the one with highest summary.line
            if [[ "${#CANDS[@]}" -gt 1 ]]; then
              found="$(python - <<'PY' "${CANDS[@]}"
      import json, sys
      from pathlib import Path

      best = None
      best_pct = -1.0

      for p in map(Path, sys.argv[1:]):
        try:
          d = json.loads(p.read_text(encoding="utf-8"))
          pct = float(d.get("summary", {}).get("line", 0.0))
        except Exception:
          pct = 0.0
        if pct > best_pct:
          best_pct = pct
          best = p

      print(str(best))
      PY
      )"
              echo "[COVERAGE] selected best-by-summary.line: ${found}"
            else
              found="${CANDS[0]}"
              echo "[COVERAGE] selected single candidate: ${found}"
            fi
          fi

          mkdir -p "$(dirname "${TARGET}")"
          cp "${found}" "${TARGET}"

          echo "[COVERAGE] ✅ materialized: ${TARGET}"
          ls -la "$(dirname "${TARGET}")"
          head -n 60 "${TARGET}" || true

      # -----------------------------------------------------------------------
      # Run coverage governance gate
      # -----------------------------------------------------------------------
      - name: Run coverage governance gate
        uses: BrikByte-Studios/.github/.github/actions/coverage-gate@main
        with:
          working-directory: ${{ inputs.working-directory }}
          coverage-file: ${{ inputs.coverage-file }}
          policy-file: ${{ inputs.policy-file }}
          baseline-file: ${{ inputs.baseline-file }}
          node-version: ${{ inputs.node-version }}
