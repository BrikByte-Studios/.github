name: "parallel-runner (partial)"

on:
  workflow_call:
    inputs:
      # ---- Core toggle -------------------------------------------------------
      parallel_enabled:
        description: "Enable sharded execution for this job."
        required: false
        default: false
        type: boolean

      # ---- Shard position ----------------------------------------------------
      # Convention:
      # - SHARD_INDEX is 0-based
      # - SHARD_TOTAL is total shards (>=1)
      shard_index:
        description: "0-based shard index (from matrix)."
        required: false
        default: 0
        type: number
      shard_total:
        description: "Total shards (>=1)."
        required: false
        default: 1
        type: number

      # ---- Mode --------------------------------------------------------------
      parallel_mode:
        description: "serial|static|dynamic (dynamic reserved for future)."
        required: false
        default: "serial"
        type: string

      # ---- Selection ---------------------------------------------------------
      selection_mode:
        description: "framework-native|file-split|none"
        required: false
        default: "file-split"
        type: string

      # Glob for file-split selection (optional; used by shard-select.mjs)
      test_glob:
        description: "Glob for selecting tests (repo-relative). Example: tests/unit/**/*.test.ts"
        required: false
        default: ""
        type: string

      # Working directory for discovery + selection
      working_directory:
        description: "Where tests live (repo-relative)."
        required: false
        default: "."
        type: string

      # Output list path (relative to repo-root) for selected files
      out_list:
        description: "Where to write selected test list."
        required: false
        default: "out/shard-files.txt"
        type: string

      # Optional discovery list file (if you already materialize items elsewhere)
      items_file:
        description: "Optional path to a precomputed test items file (repo-relative)."
        required: false
        default: ""
        type: string

    outputs:
      parallel:
        description: "true|false"
        value: ${{ jobs.parallel-runner.outputs.parallel }}
      shard_index:
        description: "0-based index"
        value: ${{ jobs.parallel-runner.outputs.shard_index }}
      shard_total:
        description: "total shards"
        value: ${{ jobs.parallel-runner.outputs.shard_total }}
      selection_path:
        description: "repo-relative path to selected tests list (if any)"
        value: ${{ jobs.parallel-runner.outputs.selection_path }}
      selection_summary:
        description: "human summary"
        value: ${{ jobs.parallel-runner.outputs.selection_summary }}

permissions:
  contents: read

jobs:
  parallel-runner:
    runs-on: ubuntu-latest
    outputs:
      parallel: ${{ steps.out.outputs.parallel }}
      shard_index: ${{ steps.out.outputs.shard_index }}
      shard_total: ${{ steps.out.outputs.shard_total }}
      selection_path: ${{ steps.out.outputs.selection_path }}
      selection_summary: ${{ steps.out.outputs.selection_summary }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate inputs + compute env contract
        id: compute
        shell: bash
        run: |
          set -euo pipefail

          # -------------------------------------------------------------------
          # Doc:
          # This step enforces the canonical contract for all workflows:
          #
          # PARALLEL=true|false
          # PARALLEL_MODE=serial|static|dynamic
          # SHARD_INDEX=0-based
          # SHARD_TOTAL=total shards (>=1)
          #
          # We keep serial a first-class mode:
          # - parallel_enabled=false OR shard_total=1 => PARALLEL=false
          # -------------------------------------------------------------------

          PARALLEL_ENABLED="${{ inputs.parallel_enabled }}"
          MODE="${{ inputs.parallel_mode }}"

          INDEX="${{ inputs.shard_index }}"
          TOTAL="${{ inputs.shard_total }}"

          # Normalize booleans into "true|false"
          if [[ "${PARALLEL_ENABLED}" == "true" && "${TOTAL}" -gt 1 ]]; then
            PARALLEL="true"
          else
            PARALLEL="false"
            MODE="serial"
            INDEX="0"
            TOTAL="1"
          fi

          # Guardrails
          if [[ "${TOTAL}" -lt 1 ]]; then
            echo "::error::shard_total must be >= 1 (got ${TOTAL})"
            exit 2
          fi
          if [[ "${INDEX}" -lt 0 || "${INDEX}" -ge "${TOTAL}" ]]; then
            echo "::error::shard_index must be in [0, shard_total-1] (got ${INDEX}/${TOTAL})"
            exit 2
          fi
          if [[ "${MODE}" != "serial" && "${MODE}" != "static" && "${MODE}" != "dynamic" ]]; then
            echo "::error::parallel_mode must be serial|static|dynamic (got ${MODE})"
            exit 2
          fi

          # Export to GITHUB_ENV for downstream steps
          {
            echo "PARALLEL=${PARALLEL}"
            echo "PARALLEL_MODE=${MODE}"
            echo "SHARD_INDEX=${INDEX}"
            echo "SHARD_TOTAL=${TOTAL}"
          } >> "$GITHUB_ENV"

          # Standard header for logs (required by DoD)
          echo "============================================================"
          echo "ðŸ”§ [PARALLEL-RUNNER] Standard CI Parallel Contract"
          echo "  PARALLEL      : ${PARALLEL}"
          echo "  PARALLEL_MODE : ${MODE}"
          echo "  SHARD         : ${INDEX}/${TOTAL} (0-based index)"
          echo "  WORKDIR       : ${{ inputs.working_directory }}"
          echo "  SEL_MODE      : ${{ inputs.selection_mode }}"
          echo "  TEST_GLOB     : ${{ inputs.test_glob }}"
          echo "============================================================"

      - name: Select deterministic test subset (file-split)
        id: select
        if: ${{ inputs.selection_mode == 'file-split' && env.PARALLEL == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          # -------------------------------------------------------------------
          # Doc:
          # This uses a deterministic algorithm:
          # - list files via glob (sorted)
          # - take items where (i % SHARD_TOTAL) == SHARD_INDEX
          #
          # The list is written to inputs.out_list (repo-relative).
          # -------------------------------------------------------------------

          GLOB="${{ inputs.test_glob }}"
          if [[ -z "${GLOB}" ]]; then
            echo "::error::selection_mode=file-split requires inputs.test_glob"
            exit 2
          fi

          node ".github/scripts/shard-select.mjs" \
            --workdir "${{ inputs.working_directory }}" \
            --glob "${GLOB}" \
            --index "${SHARD_INDEX}" \
            --total "${SHARD_TOTAL}" \
            --out "${{ inputs.out_list }}"

      - name: Adopt precomputed items_file (optional)
        id: items
        if: ${{ inputs.items_file != '' && env.PARALLEL == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          # If the caller already generated a list (e.g. out/test-items.txt),
          # keep it available for frameworks that consume it directly.
          if [[ ! -f "${{ inputs.items_file }}" ]]; then
            echo "::error::items_file not found: ${{ inputs.items_file }}"
            exit 2
          fi
          echo "[PARALLEL-RUNNER] items_file present: ${{ inputs.items_file }}"
          echo "[PARALLEL-RUNNER] lines: $(wc -l < "${{ inputs.items_file }}")"

      - name: Emit outputs
        id: out
        shell: bash
        run: |
          set -euo pipefail

          SEL_PATH=""
          SEL_SUMMARY="selection: none"

          if [[ "${PARALLEL}" == "true" && "${{ inputs.selection_mode }}" == "file-split" ]]; then
            SEL_PATH="${{ inputs.out_list }}"
            if [[ -f "${SEL_PATH}" ]]; then
              COUNT="$(wc -l < "${SEL_PATH}" | tr -d ' ')"
              SEL_SUMMARY="selection: ${COUNT} files -> ${SEL_PATH}"
            else
              SEL_SUMMARY="selection: expected list missing -> ${SEL_PATH}"
            fi
          fi

          echo "parallel=${PARALLEL}" >> "$GITHUB_OUTPUT"
          echo "shard_index=${SHARD_INDEX}" >> "$GITHUB_OUTPUT"
          echo "shard_total=${SHARD_TOTAL}" >> "$GITHUB_OUTPUT"
          echo "selection_path=${SEL_PATH}" >> "$GITHUB_OUTPUT"
          echo "selection_summary=${SEL_SUMMARY}" >> "$GITHUB_OUTPUT"

          echo "[PARALLEL-RUNNER] ${SEL_SUMMARY}"
