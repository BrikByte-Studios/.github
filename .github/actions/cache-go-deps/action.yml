# ======================================================================
# BrikByteOS â€” Go Dependency & Build Cache (Go Modules)
# ----------------------------------------------------------------------
# TASK (Go equivalent of JVM/Node/Python caching):
#   PIPE-CACHE-GO-BUILD-00X â€” Implement Go module + build cache
#
# PURPOSE:
#   Provide a reusable GitHub Actions *composite action* that:
#     - Caches Go modules + build cache for Go projects using modules.
#     - Cache paths:
#         â€¢ Module cache:  $GOMODCACHE (or GOPATH/pkg/mod)
#         â€¢ Build cache:   ~/.cache/go-build
#     - Cache key includes:
#         â€¢ OS (runner.os)
#         â€¢ Go version (go-version input)
#         â€¢ go.mod / go.sum hash (from project-path)
#
# USAGE (EXAMPLE):
#
#   # In a consumer workflow (e.g. brik-pipe-examples/go-api-example CI):
#
#   env:
#     GO_VERSION: "1.22"
#
#   jobs:
#     build:
#       runs-on: ubuntu-latest
#       steps:
#         - uses: actions/checkout@v4
#
#         - name: "Setup Go"
#           uses: actions/setup-go@v5
#           with:
#             go-version: ${{ env.GO_VERSION }}
#
#         - name: "Cache Go modules & build cache"
#           uses: BrikByte-Studios/.github/.github/actions/cache-go-deps@main
#           with:
#             go-version: ${{ env.GO_VERSION }}
#             project-path: go-api-example
#
#         - name: "Build & test"
#           working-directory: go-api-example
#           run: |
#             go test ./...
#             go build ./...
#
# NOTES:
#   - Designed for Go modules (go.mod/go.sum present).
#   - For monorepos, `project-path` points at the Go module root.
#   - No secrets required; uses actions/cache only.
# ======================================================================

name: "Cache Go Dependencies (Go Modules + Build Cache)"
description: >
  BrikByteOS composite action to cache Go module & build cache using
  Go-versionâ€“ and go.mod/go.sumâ€“aware keys.

inputs:
  go-version:
    description: >
      Go version used in CI (e.g. 1.21, 1.22). This MUST match the version
      configured via actions/setup-go for safe cache reuse.
    required: true

  project-path:
    description: >
      Relative path to the Go module root (where go.mod/go.sum live).
      Defaults to '.' for single-project repos.
    required: false
    default: "."

outputs:
  cache-path:
    description: "Root paths cached (modules + build cache, comma-separated)"
    value: ${{ steps.cache-go.outputs.cache-paths }}

runs:
  using: "composite"
  steps:
    # -------------------------------------------------------------------
    # 1) Discover module info & set cache paths
    #
    #    - Validates go.mod presence under project-path.
    #    - Computes:
    #        â€¢ MODULE_PATH = project-path
    #        â€¢ GOMODFILE   = go.mod under that path
    #        â€¢ GO_SUM      = go.sum (if present)
    #
    #    - Cache paths:
    #        â€¢ Module cache  â†’ $GOMODCACHE or GOPATH/pkg/mod fallback
    #        â€¢ Build cache   â†’ ~/.cache/go-build
    #
    #    - These paths are *outside* the repo and reused across jobs.
    # -------------------------------------------------------------------
    - name: "Detect Go module & cache paths"
      id: detect
      shell: bash
      run: |
        set -euo pipefail

        MODULE_PATH="${{ inputs.project-path }}"
        echo "ðŸ” Inspecting Go module at: ${MODULE_PATH}"

        if [ ! -f "${MODULE_PATH}/go.mod" ]; then
          echo "::notice::No go.mod found at '${MODULE_PATH}'. Skipping Go cache."
          echo "enabled=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "enabled=true" >> "$GITHUB_OUTPUT"

        # Build cache (safe)
        GOCACHE="$(go env GOCACHE || true)"
        if [ -z "${GOCACHE}" ]; then
          GOCACHE="${HOME}/.cache/go-build"
        fi

        # Module download cache (safe subset)
        GOMODCACHE="$(go env GOMODCACHE || true)"
        if [ -z "${GOMODCACHE}" ]; then
          GOPATH_VAL="$(go env GOPATH)"
          GOMODCACHE="${GOPATH_VAL}/pkg/mod"
        fi
        GODOWNLOADCACHE="${GOMODCACHE}/cache/download"

        echo "ðŸ§± GOCACHE:          ${GOCACHE}"
        echo "ðŸ“¥ Download cache:   ${GODOWNLOADCACHE}"

        echo "gocache=${GOCACHE}" >> "$GITHUB_OUTPUT"
        echo "godownloadcache=${GODOWNLOADCACHE}" >> "$GITHUB_OUTPUT"

    - name: "Debug cache paths"
      if: ${{ steps.detect.outputs.enabled == 'true' }}
      shell: bash
      run: |
        echo "gocache='${{ steps.detect.outputs.gocache }}'"
        echo "godownloadcache='${{ steps.detect.outputs.godownloadcache }}'"


    # -------------------------------------------------------------------
    # 2) Cache Go module + build cache
    #
    #    - Only runs if go.mod is present.
    #    - Key components:
    #        â€¢ go-<os>-<go-version>-<hash(go.mod/go.sum)>
    #
    #    - Paths cached:
    #        â€¢ <GOMODCACHE>
    #        â€¢ ~/.cache/go-build
    # -------------------------------------------------------------------
    - name: "Cache Go (build + download cache)"
      id: cache
      if: ${{ steps.detect.outputs.enabled == 'true' && steps.detect.outputs.gocache != '' && steps.detect.outputs.godownloadcache != '' }}
      uses: actions/cache@v4
      with:
        path: |
          ${{ steps.detect.outputs.gocache }}
          ${{ steps.detect.outputs.godownloadcache }}
        key: >
          go-${{ runner.os }}-${{ inputs.go-version }}-${{
            hashFiles(
              format('{0}/go.mod', inputs['project-path']),
              format('{0}/go.sum', inputs['project-path'])
            )
          }}
        restore-keys: |
          go-${{ runner.os }}-${{ inputs.go-version }}-


    # -------------------------------------------------------------------
    # 3) Log cache result for observability
    # -------------------------------------------------------------------
    - name: "Summarize Go cache result"
      id: summary
      if: ${{ steps.detect.outputs.enabled == 'true' }}
      shell: bash
      run: |
        set -euo pipefail

        CACHE_HIT="${{ steps.cache-go.outputs.cache-hit }}"
        GOCACHE="${{ steps.detect.outputs.gocache }}"
        GODOWNLOADCACHE="${{ steps.detect.outputs.godownloadcache }}"

        if [ "${CACHE_HIT}" = "true" ]; then
          echo "âœ… Go cache HIT."
        else
          echo "â„¹ï¸ Go cache MISS â€” will save after job."
        fi

        echo "   â€¢ GOCACHE        : ${GOCACHE}"
        echo "   â€¢ Download cache : ${GODOWNLOADCACHE}"
        echo "cache-paths=${GOCACHE},${GODOWNLOADCACHE}" >> "$GITHUB_OUTPUT"
