# ======================================================================
# BrikByteOS — Python Dependency Cache (pip / Poetry / Pipenv)
#
# Purpose:
#   - Provide a reusable composite action that:
#       * Detects which Python toolchain is in use:
#           - pip        (requirements.txt)
#           - Poetry     (poetry.lock)
#           - Pipenv     (Pipfile.lock)
#       * Configures Poetry to use in-project virtualenvs (.venv) for
#         reproducibility when poetry.lock is present.
#       * Restores/saves a cache for the appropriate dependency store:
#           - pip:     ~/.cache/pip
#           - Poetry:  .venv  (project-local virtualenv)
#           - Pipenv:  ~/.local/share/virtualenvs
#       * Uses lockfile + Python version in cache key to avoid ABI conflicts.
#
# Usage:
#   - In your workflow, set PYTHON_VERSION or pass python-version directly:
#
#       env:
#         PYTHON_VERSION: "3.11"
#
#       - uses: actions/setup-python@v5
#         with:
#           python-version: ${{ env.PYTHON_VERSION }}
#
#       - name: "Cache Python deps (pip / Poetry / Pipenv)"
#         uses: BrikByte-Studios/.github/.github/actions/cache-python-deps@main
#         with:
#           python-version: ${{ env.PYTHON_VERSION }}
#
#   - Then run `pip install` / `poetry install` / `pipenv install` as normal.
# ======================================================================

name: "Cache Python Dependencies (pip / Poetry / Pipenv)"
description: >
  BrikByteOS composite action that detects pip / Poetry / Pipenv and
  restores/saves a dependency cache keyed by Python version + lockfile hash.

inputs:
  python-version:
    description: >
      Python version used in CI (e.g. "3.10", "3.11"). This is used as part
      of the cache key to avoid ABI conflicts between Python versions.
    required: true

runs:
  using: "composite"
  steps:
    # ---------------------------------------------------------------
    # 1) Detect Python dependency toolchain and lockfile
    #
    #    Priority:
    #      - Pipenv  → Pipfile.lock
    #      - Poetry  → poetry.lock
    #      - pip     → requirements.txt
    #
    #    Outputs:
    #      - tool       → pip | poetry | pipenv | none
    #      - cache_path → directory to cache
    #      - lockfile   → lockfile path (if any)
    # ---------------------------------------------------------------
    - name: "Detect Python dependency toolchain"
      id: detect
      shell: bash
      run: |
        set -euo pipefail

        tool="none"
        cache_path=""
        lockfile=""

        if [ -f "Pipfile.lock" ]; then
          tool="pipenv"
          # Pipenv default virtualenv store; we rely on lockfile + version
          # in key to avoid cross-project pollution.
          cache_path="${HOME}/.local/share/virtualenvs"
          lockfile="Pipfile.lock"
          echo "::notice::Detected Pipenv (Pipfile.lock)."
        elif [ -f "poetry.lock" ]; then
          tool="poetry"
          # We will configure Poetry to use an in-project virtualenv (.venv)
          # so cache path is stable and tied to this repo.
          cache_path=".venv"
          lockfile="poetry.lock"
          echo "::notice::Detected Poetry (poetry.lock)."
        elif [ -f "requirements.txt" ]; then
          tool="pip"
          cache_path="${HOME}/.cache/pip"
          lockfile="requirements.txt"
          echo "::notice::Detected pip (requirements.txt)."
        else
          echo "::notice::No Pipfile.lock, poetry.lock, or requirements.txt found; Python cache will be skipped."
        fi

        echo "tool=${tool}"       >> "$GITHUB_OUTPUT"
        echo "cache_path=${cache_path}" >> "$GITHUB_OUTPUT"
        echo "lockfile=${lockfile}"     >> "$GITHUB_OUTPUT"

    # ---------------------------------------------------------------
    # 2) Configure Poetry to use in-project virtualenvs (if applicable)
    #
    #    - This enforces reproducible .venv usage and aligns with cache_path.
    #    - If Poetry is not yet installed, we emit a warning but do not fail.
    # ---------------------------------------------------------------
    - name: "Configure Poetry virtualenv (in-project .venv)"
      if: ${{ steps.detect.outputs.tool == 'poetry' }}
      shell: bash
      run: |
        set -euo pipefail

        if command -v poetry >/dev/null 2>&1; then
          echo "Configuring Poetry to use in-project virtualenv (.venv)..."
          poetry config virtualenvs.in-project true
          poetry config virtualenvs.create true
        else
          echo "::warning::poetry.lock present, but 'poetry' is not installed yet."
          echo "::warning::Install Poetry BEFORE this cache action for best behavior."
        fi

    # ---------------------------------------------------------------
    # 3) Cache Python dependencies
    #
    #    - Skips if no supported lockfile is found (tool == none).
    #    - Key includes:
    #        runner.os, python-version, tool, lockfile hash.
    # ---------------------------------------------------------------
    - name: "Cache Python dependencies"
      if: ${{ steps.detect.outputs.tool != 'none' }}
      uses: actions/cache@v4
      with:
        # Resolved cache path for the detected tool:
        #   pip     → ~/.cache/pip
        #   poetry  → .venv
        #   pipenv  → ~/.local/share/virtualenvs
        path: ${{ steps.detect.outputs.cache_path }}

        # Key includes:
        #   - OS
        #   - Python version
        #   - Tool name
        #   - Hash of all supported lockfiles (only one should exist at a time)
        key: >
          python-${{ runner.os }}-${{ inputs.python-version }}-${{ steps.detect.outputs.tool }}-${{
            hashFiles('**/requirements.txt', '**/poetry.lock', '**/Pipfile.lock')
          }}

        # Restore key prefix to make minor changes still hit a close cache
        restore-keys: |
          python-${{ runner.os }}-${{ inputs.python-version }}-${{ steps.detect.outputs.tool }}-
