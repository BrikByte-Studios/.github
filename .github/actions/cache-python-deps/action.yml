# ======================================================================
# BrikByteOS — Python Dependency Cache (pip / Poetry / Pipenv)
#
# Purpose:
#   - Provide a reusable composite action that:
#       * Detects which Python toolchain is in use in a given project path:
#           - pip        (requirements.txt)
#           - Poetry     (poetry.lock)
#           - Pipenv     (Pipfile.lock)
#       * Configures Poetry to use in-project virtualenvs (.venv) for
#         reproducibility when poetry.lock is present.
#       * Restores/saves a cache for the appropriate dependency store:
#           - pip:     ~/.cache/pip
#           - Poetry:  .venv  (project-local virtualenv)
#           - Pipenv:  ~/.local/share/virtualenvs
#       * Uses lockfile + Python version in cache key to avoid ABI conflicts.
#
# Usage (example):
#
#   env:
#     PYTHON_VERSION: "3.11"
#
#   - uses: actions/setup-python@v5
#     with:
#       python-version: ${{ env.PYTHON_VERSION }}
#
#   - name: "Cache Python deps (pip / Poetry / Pipenv)"
#     uses: BrikByte-Studios/.github/.github/actions/cache-python-deps@main
#     with:
#       python-version: ${{ env.PYTHON_VERSION }}
#       project-path: python-api-example
#
#   - name: Install deps
#     working-directory: python-api-example
#     run: |
#       # pip example:
#       pip install -r requirements.txt
#
#       # poetry example:
#       # poetry install --no-interaction --no-ansi
#
#       # pipenv example:
#       # pipenv install --dev
# ======================================================================

name: "Cache Python Dependencies (pip / Poetry / Pipenv)"
description: >
  BrikByteOS composite action that detects pip / Poetry / Pipenv in a given
  project path and restores/saves a dependency cache keyed by Python version
  + lockfile hash.

inputs:
  python-version:
    description: >
      Python version used in CI (e.g. "3.10", "3.11"). This is used as part
      of the cache key to avoid ABI conflicts between Python versions.
    required: true
  project-path:
    description: >
      Relative path to the Python project root (where requirements.txt,
      poetry.lock, or Pipfile.lock live).
    required: false
    default: "."

runs:
  using: "composite"
  steps:
    # ---------------------------------------------------------------
    # 1) Detect Python dependency toolchain and lockfile
    #
    #    Priority:
    #      - Pipenv  → Pipfile.lock
    #      - Poetry  → poetry.lock
    #      - pip     → requirements.txt
    #
    #    Outputs:
    #      - tool       → pip | poetry | pipenv | none
    #      - cache_path → directory to cache
    #      - lockfile   → lockfile name (relative to project-path)
    # ---------------------------------------------------------------
    - name: "Detect Python dependency toolchain"
      id: detect
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        set -euo pipefail

        tool="none"
        cache_path=""
        lockfile=""

        if [ -f "Pipfile.lock" ]; then
          tool="pipenv"
          # Pipenv default virtualenv store; we rely on lockfile + version
          # in key to avoid cross-project pollution.
          cache_path="${HOME}/.local/share/virtualenvs"
          lockfile="Pipfile.lock"
          echo "::notice::Detected Pipenv (Pipfile.lock) in ${PWD}."
        elif [ -f "poetry.lock" ]; then
          tool="poetry"
          # We'll configure Poetry to use an in-project virtualenv (.venv)
          # so cache path is stable and tied to this repo.
          cache_path=".venv"
          lockfile="poetry.lock"
          echo "::notice::Detected Poetry (poetry.lock) in ${PWD}."
        elif [ -f "requirements.txt" ]; then
          tool="pip"
          cache_path="${HOME}/.cache/pip"
          lockfile="requirements.txt"
          echo "::notice::Detected pip (requirements.txt) in ${PWD}."
        else
          echo "::notice::No Python lock/requirements files detected in '${PWD}'."
          echo "::notice::Skipping Python dependency cache."
        fi

        echo "tool=${tool}"             >> "$GITHUB_OUTPUT"
        echo "cache_path=${cache_path}" >> "$GITHUB_OUTPUT"
        echo "lockfile=${lockfile}"     >> "$GITHUB_OUTPUT"

    # ---------------------------------------------------------------
    # 2) Configure Poetry to use in-project virtualenvs (if applicable)
    #
    #    - This enforces reproducible .venv usage and aligns with cache_path.
    #    - If Poetry is not yet installed, we emit a warning but do not fail.
    # ---------------------------------------------------------------
    - name: "Configure Poetry virtualenv (in-project .venv)"
      if: ${{ steps.detect.outputs.tool == 'poetry' }}
      shell: bash
      working-directory: ${{ inputs.project-path }}
      run: |
        set -euo pipefail

        if command -v poetry >/dev/null 2>&1; then
          echo "Configuring Poetry to use in-project virtualenv (.venv)..."
          poetry config virtualenvs.in-project true
          poetry config virtualenvs.create true
        else
          echo "::warning::poetry.lock present in '${PWD}', but 'poetry' is not installed yet."
          echo "::warning::Install Poetry BEFORE this cache action for best behavior."
        fi

    # ---------------------------------------------------------------
    # 3) Cache Python dependencies
    #
    #    - Skips if no supported lockfile is found (tool == none).
    #    - Key includes:
    #        runner.os, python-version, tool, lockfile hash (scoped to project-path).
    # ---------------------------------------------------------------
    - name: "Cache Python dependencies"
      if: ${{ steps.detect.outputs.tool != 'none' }}
      uses: actions/cache@v4
      with:
        # Resolved cache path for the detected tool:
        #   pip     → ~/.cache/pip
        #   poetry  → .venv (in-project)
        #   pipenv  → ~/.local/share/virtualenvs
        path: ${{ steps.detect.outputs.cache_path }}

        # Key includes:
        #   - OS
        #   - Python version
        #   - Tool name
        #   - Hash of relevant lockfiles under project-path
        key: >
          python-${{ runner.os }}-${{ inputs.python-version }}-${{ steps.detect.outputs.tool }}-${{
            hashFiles(
              format('{0}/requirements.txt', inputs['project-path']),
              format('{0}/poetry.lock', inputs['project-path']),
              format('{0}/Pipfile.lock', inputs['project-path'])
            )
          }}

        # Restore key prefix to make minor changes still hit a close cache
        restore-keys: |
          python-${{ runner.os }}-${{ inputs.python-version }}-${{ steps.detect.outputs.tool }}-
